{
  "version": 3,
  "sources": ["../../../../../src/content/dicecloud-extraction.js", "../../../../../src/popup/adapters/rollcloud/adapter.js"],
  "sourcesContent": ["/**\r\n * Comprehensive DiceCloud character data extraction\r\n * Copied from proven OwlCloud implementation\r\n */\r\n\r\n// Standardized DiceCloud variable names\r\nconst STANDARD_VARS = {\r\n  abilities: ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'],\r\n  abilityMods: ['strengthMod', 'dexterityMod', 'constitutionMod', 'intelligenceMod', 'wisdomMod', 'charismaMod'],\r\n  saves: ['strengthSave', 'dexteritySave', 'constitutionSave', 'intelligenceSave', 'wisdomSave', 'charismaSave'],\r\n  skills: [\r\n    'acrobatics', 'animalHandling', 'arcana', 'athletics', 'deception', 'history',\r\n    'insight', 'intimidation', 'investigation', 'medicine', 'nature', 'perception',\r\n    'performance', 'persuasion', 'religion', 'sleightOfHand', 'stealth', 'survival'\r\n  ],\r\n  combat: ['armorClass', 'hitPoints', 'speed', 'initiative', 'proficiencyBonus']\r\n};\r\n\r\n/**\r\n * Determines hit die type from character class (D&D 5e)\r\n */\r\nfunction getHitDieTypeFromClass(levels) {\r\n  const hitDiceMap = {\r\n    'barbarian': 'd12',\r\n    'fighter': 'd10',\r\n    'paladin': 'd10',\r\n    'ranger': 'd10',\r\n    'bard': 'd8',\r\n    'cleric': 'd8',\r\n    'druid': 'd8',\r\n    'monk': 'd8',\r\n    'rogue': 'd8',\r\n    'warlock': 'd8',\r\n    'sorcerer': 'd6',\r\n    'wizard': 'd6'\r\n  };\r\n\r\n  if (levels && levels.length > 0) {\r\n    const primaryClass = levels[0]?.name?.toLowerCase() || '';\r\n    for (const [classKey, die] of Object.entries(hitDiceMap)) {\r\n      if (primaryClass.includes(classKey)) {\r\n        return die;\r\n      }\r\n    }\r\n  }\r\n\r\n  return 'd8'; // Default\r\n}\r\n\r\n/**\r\n * Parses API response into structured character data\r\n */\r\nexport function parseCharacterData(apiData, characterId) {\r\n  console.log('CarmaClouds: Parsing character data...');\r\n\r\n  if (!apiData.creatures || apiData.creatures.length === 0) {\r\n    console.error('CarmaClouds: No creatures found in API response');\r\n    throw new Error('No character data found in API response');\r\n  }\r\n\r\n  const creature = apiData.creatures[0];\r\n  const variables = (apiData.creatureVariables && apiData.creatureVariables[0]) || {};\r\n  const properties = apiData.creatureProperties || [];\r\n\r\n  console.log('CarmaClouds: Creature:', creature.name);\r\n  console.log('CarmaClouds: Variables count:', Object.keys(variables).length);\r\n  console.log('CarmaClouds: Properties count:', properties.length);\r\n\r\n  // Calculate AC from multiple sources\r\n  const calculateArmorClass = () => {\r\n    // Helper: try to coerce a variety of shapes into a numeric AC\r\n    const extractNumeric = (val) => {\r\n      if (val === null || val === undefined) return null;\r\n      if (typeof val === 'number' && !isNaN(val)) return val;\r\n      if (typeof val === 'string') {\r\n        const parsed = parseFloat(val);\r\n        return isNaN(parsed) ? null : parsed;\r\n      }\r\n      if (typeof val === 'object') {\r\n        if (val.total !== undefined && typeof val.total === 'number') return val.total;\r\n        if (val.value !== undefined && typeof val.value === 'number') return val.value;\r\n        if (val.calculation && typeof val.calculation === 'string') {\r\n          const bm = val.calculation.match(/^(\\d+)/);\r\n          if (bm) return parseInt(bm[1]);\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n\r\n    // Check if Dicecloud provided a calculated AC (most reliable)\r\n    if (variables.armorClass && (variables.armorClass.total || variables.armorClass.value)) {\r\n      const variableAC = variables.armorClass.total || variables.armorClass.value;\r\n      console.log(`CarmaClouds: Using Dicecloud's calculated AC: ${variableAC}`);\r\n      return variableAC;\r\n    }\r\n\r\n    // Try denormalizedStats\r\n    if (creature && creature.denormalizedStats) {\r\n      const tryKeys = ['armorClass', 'ac', 'armor'];\r\n      for (const k of tryKeys) {\r\n        if (creature.denormalizedStats.hasOwnProperty(k)) {\r\n          const num = extractNumeric(creature.denormalizedStats[k]);\r\n          if (num !== null) {\r\n            console.log(`CarmaClouds: Using denormalizedStats.${k}:`, num);\r\n            return num;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check variables for AC\r\n    const varNamesToCheck = ['armor', 'armorClass', 'armor_class', 'ac', 'acTotal'];\r\n    for (const vn of varNamesToCheck) {\r\n      if (variables.hasOwnProperty(vn)) {\r\n        const v = variables[vn];\r\n        const candidate = extractNumeric(v && (v.total ?? v.value ?? v));\r\n        if (candidate !== null) {\r\n          console.log(`CarmaClouds: Using variable ${vn}:`, candidate);\r\n          return candidate;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate from properties (base + armor + bonuses)\r\n    let baseAC = 10;\r\n    let armorAC = null;\r\n    const acBonuses = [];\r\n\r\n    properties.forEach(prop => {\r\n      if (prop.inactive || prop.disabled) return;\r\n\r\n      const hasArmorStat = prop.stat === 'armor' ||\r\n                          (Array.isArray(prop.stats) && prop.stats.includes('armor'));\r\n\r\n      if (hasArmorStat) {\r\n        let amount = null;\r\n        if (typeof prop.amount === 'number') {\r\n          amount = prop.amount;\r\n        } else if (typeof prop.amount === 'string') {\r\n          amount = parseFloat(prop.amount);\r\n        }\r\n\r\n        if (amount !== null && !isNaN(amount)) {\r\n          const operation = prop.operation || '';\r\n\r\n          if (operation === 'base' || operation === 'Base value') {\r\n            if (armorAC === null || amount > armorAC) {\r\n              armorAC = amount;\r\n            }\r\n          } else if (operation === 'add' || operation === 'Add') {\r\n            acBonuses.push({ name: prop.name, amount });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    let finalAC = armorAC !== null ? armorAC : baseAC;\r\n    acBonuses.forEach(bonus => {\r\n      finalAC += bonus.amount;\r\n    });\r\n\r\n    console.log('CarmaClouds: Calculated AC:', finalAC);\r\n    return finalAC;\r\n  };\r\n\r\n  // Extract race, class, and level from properties\r\n  let characterRace = 'Unknown';\r\n  let characterClass = '';\r\n  let characterLevel = 0;\r\n  const uniqueClasses = new Set();\r\n  let raceFound = false;\r\n\r\n  console.log('CarmaClouds: Extracting basic character info...');\r\n\r\n  // Debug: Log all property types to help identify race\r\n  const propertyTypes = {};\r\n  properties.forEach(prop => {\r\n    if (prop && prop.type) {\r\n      propertyTypes[prop.type] = (propertyTypes[prop.type] || 0) + 1;\r\n    }\r\n  });\r\n  console.log('CarmaClouds: Property types in character:', propertyTypes);\r\n\r\n  // Just extract basic metadata for display\r\n  let characterName = creature.name || '';\r\n\r\n  // Check if race is stored directly on creature\r\n  if (creature.race) {\r\n    console.log('CarmaClouds: Found race on creature:', creature.race);\r\n    characterRace = creature.race;\r\n    raceFound = true;\r\n  }\r\n  if (creature.denormalizedStats && creature.denormalizedStats.race) {\r\n    console.log('CarmaClouds: Found race in denormalizedStats:', creature.denormalizedStats.race);\r\n    characterRace = creature.denormalizedStats.race;\r\n    raceFound = true;\r\n  }\r\n\r\n  for (const prop of properties) {\r\n    if (!prop) continue;\r\n\r\n    // Check for race as a folder (DiceCloud often stores races as folders)\r\n    // Look for folders with common race names at the top level\r\n    if (!raceFound && prop.type === 'folder' && prop.name) {\r\n      const commonRaces = ['human', 'elf', 'dwarf', 'halfling', 'gnome', 'half-elf', 'half-orc', 'dragonborn', 'tiefling', 'orc', 'goblin', 'kobold', 'warforged', 'tabaxi', 'kenku', 'aarakocra', 'genasi', 'aasimar', 'firbolg', 'goliath', 'triton', 'yuan-ti', 'tortle', 'lizardfolk', 'bugbear', 'hobgoblin', 'changeling', 'shifter', 'kalashtar'];\r\n      const nameMatchesRace = commonRaces.some(race => prop.name.toLowerCase().includes(race));\r\n      if (nameMatchesRace) {\r\n        const parentDepth = prop.ancestors ? prop.ancestors.length : 0;\r\n        if (parentDepth <= 2) { // Top-level or near top-level folder\r\n          console.log('CarmaClouds: Found race folder:', prop.name);\r\n          characterRace = prop.name;\r\n          raceFound = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract race for preview - check multiple possible types\r\n    if (!raceFound && (prop.type === 'race' || prop.type === 'species' || prop.type === 'characterRace')) {\r\n      if (prop.name) {\r\n        console.log('CarmaClouds: Found race property:', prop.type, prop.name);\r\n        characterRace = prop.name;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // Check if it's a constant named \"Race\" (DiceCloud v2 stores race as a constant)\r\n    if (!raceFound && prop.type === 'constant' && prop.name && prop.name.toLowerCase() === 'race') {\r\n      if (prop.value) {\r\n        console.log('CarmaClouds: Found race as constant:', prop.value);\r\n        characterRace = prop.value;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // Extract class for preview\r\n    if (prop.type === 'class' && prop.name && !prop.inactive && !prop.disabled) {\r\n      const cleanName = prop.name.replace(/\\s*\\[Multiclass\\]/i, '').trim();\r\n      const normalizedClassName = cleanName.toLowerCase().trim();\r\n      if (!uniqueClasses.has(normalizedClassName)) {\r\n        uniqueClasses.add(normalizedClassName);\r\n        if (characterClass) {\r\n          characterClass += ` / ${cleanName}`;\r\n        } else {\r\n          characterClass = cleanName;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract level for preview\r\n    if (prop.type === 'classLevel' && !prop.inactive && !prop.disabled) {\r\n      characterLevel += 1;\r\n    }\r\n  }\r\n\r\n  // Fallback: Check for race in variables if not found in properties\r\n  if (!raceFound && (!characterRace || characterRace === 'Unknown')) {\r\n    console.log('CarmaClouds: Race not found in properties, checking variables...');\r\n    const raceVars = Object.keys(variables).filter(key =>\r\n      key.toLowerCase().includes('race') || key.toLowerCase().includes('species')\r\n    );\r\n\r\n    if (raceVars.length > 0) {\r\n      console.log('CarmaClouds: Found race-related variables:', raceVars);\r\n\r\n      // Log raw data for each race variable\r\n      raceVars.forEach(varName => {\r\n        console.log(`CarmaClouds: Raw data for \"${varName}\":`, variables[varName]);\r\n      });\r\n\r\n      // Helper function to format camelCase race names\r\n      const formatRaceName = (name) => {\r\n        if (!name) return null;\r\n        if (name.toLowerCase() === 'custom' || name.toLowerCase() === 'customlineage') {\r\n          return 'Custom Lineage';\r\n        }\r\n        let formatted = name.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n        formatted = formatted.split(' ').map(word =>\r\n          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n        ).join(' ');\r\n        return formatted;\r\n      };\r\n\r\n      // Helper function to extract race name from variable name\r\n      const extractRaceFromVarName = (varName) => {\r\n        const raceName = varName.replace(/race$/i, '').replace(/^race$/i, '');\r\n        if (raceName && raceName !== varName.toLowerCase()) {\r\n          return raceName.charAt(0).toUpperCase() + raceName.slice(1);\r\n        }\r\n        return null;\r\n      };\r\n\r\n      let raceName = null;\r\n      let subraceName = null;\r\n\r\n      // Check for subRace first\r\n      const subRaceVar = raceVars.find(key => key.toLowerCase() === 'subrace');\r\n      if (subRaceVar) {\r\n        const subRaceValue = variables[subRaceVar];\r\n        console.log('CarmaClouds: Found subRace variable:', subRaceValue);\r\n        if (typeof subRaceValue === 'object' && subRaceValue !== null) {\r\n          if (subRaceValue.name) {\r\n            subraceName = formatRaceName(subRaceValue.name);\r\n          } else if (subRaceValue.text) {\r\n            subraceName = formatRaceName(subRaceValue.text);\r\n          } else if (subRaceValue.value) {\r\n            subraceName = formatRaceName(subRaceValue.value);\r\n          }\r\n        } else if (typeof subRaceValue === 'string') {\r\n          subraceName = formatRaceName(subRaceValue);\r\n        }\r\n      }\r\n\r\n      // Check for race variable\r\n      const raceVar = raceVars.find(key => key.toLowerCase() === 'race');\r\n      if (raceVar) {\r\n        const raceValue = variables[raceVar];\r\n        console.log('CarmaClouds: Found race variable:', raceValue);\r\n        if (typeof raceValue === 'object' && raceValue !== null) {\r\n          // Check for nested value.value (DiceCloud constants have this structure)\r\n          if (raceValue.value && typeof raceValue.value === 'object' && raceValue.value.value) {\r\n            raceName = formatRaceName(raceValue.value.value);\r\n            console.log('CarmaClouds: Extracted race from nested value.value:', raceName);\r\n          } else if (raceValue.value && typeof raceValue.value === 'string') {\r\n            raceName = formatRaceName(raceValue.value);\r\n          } else if (raceValue.name) {\r\n            raceName = formatRaceName(raceValue.name);\r\n          } else if (raceValue.text) {\r\n            raceName = formatRaceName(raceValue.text);\r\n          }\r\n        } else if (typeof raceValue === 'string') {\r\n          raceName = formatRaceName(raceValue);\r\n        }\r\n      }\r\n\r\n      // If we didn't find race/subrace with names, look for specific race variables\r\n      if (!raceName) {\r\n        for (const varName of raceVars) {\r\n          const varValue = variables[varName];\r\n          if (typeof varValue === 'object' && varValue !== null && varValue.value === true) {\r\n            const extracted = extractRaceFromVarName(varName);\r\n            if (extracted) {\r\n              raceName = extracted;\r\n              console.log('CarmaClouds: Extracted race from variable name:', varName, '->', raceName);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Combine race and subrace if we have both\r\n      if (raceName && subraceName) {\r\n        characterRace = `${raceName} - ${subraceName}`;\r\n        console.log('CarmaClouds: Combined race and subrace:', characterRace);\r\n      } else if (subraceName) {\r\n        characterRace = subraceName;\r\n        console.log('CarmaClouds: Using subrace as race:', characterRace);\r\n      } else if (raceName) {\r\n        characterRace = raceName;\r\n        console.log('CarmaClouds: Using race:', characterRace);\r\n      } else {\r\n        console.log('CarmaClouds: Could not determine race from variables');\r\n      }\r\n    } else {\r\n      console.log('CarmaClouds: No race variables found');\r\n    }\r\n  }\r\n\r\n  console.log('CarmaClouds: Character preview:', characterName, characterLevel, characterRace, characterClass);\r\n\r\n  // Store just raw data + metadata - parsing happens per-VTT when tabs load\r\n  const characterData = {\r\n    // Metadata\r\n    id: creature._id || characterId,\r\n    name: characterName,\r\n    url: window.location.href,\r\n    timestamp: new Date().toISOString(),\r\n    source: 'dicecloud',\r\n\r\n    // Preview info (for character lists, etc.)\r\n    preview: {\r\n      race: characterRace,\r\n      class: characterClass || 'Unknown',\r\n      level: characterLevel\r\n    },\r\n\r\n    // Raw DiceCloud API data - VTT adapters will parse this as needed\r\n    raw: {\r\n      creature: creature,\r\n      variables: variables,\r\n      properties: properties\r\n    }\r\n  };\r\n\r\n  console.log('CarmaClouds: Successfully stored character data:', characterData.name);\r\n  return characterData;\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Roll20-specific format\r\n * Called by RollCloud adapter when tab is loaded\r\n */\r\nexport function parseForRollCloud(rawData) {\r\n  if (!rawData || !rawData.creature || !rawData.variables || !rawData.properties) {\r\n    throw new Error('Invalid raw data format');\r\n  }\r\n\r\n  const { creature, variables, properties } = rawData;\r\n\r\n  // Extract race, class, level\r\n  let race = 'Unknown';\r\n  let characterClass = '';\r\n  let level = 0;\r\n  const uniqueClasses = new Set();\r\n  let raceFound = false;\r\n\r\n  for (const prop of properties) {\r\n    if (!prop) continue;\r\n\r\n    // Check for race as a folder (DiceCloud often stores races as folders)\r\n    if (!raceFound && prop.type === 'folder' && prop.name) {\r\n      const commonRaces = ['human', 'elf', 'dwarf', 'halfling', 'gnome', 'half-elf', 'half-orc', 'dragonborn', 'tiefling', 'orc', 'goblin', 'kobold', 'warforged', 'tabaxi', 'kenku', 'aarakocra', 'genasi', 'aasimar', 'firbolg', 'goliath', 'triton', 'yuan-ti', 'tortle', 'lizardfolk', 'bugbear', 'hobgoblin', 'changeling', 'shifter', 'kalashtar'];\r\n      const nameMatchesRace = commonRaces.some(r => prop.name.toLowerCase().includes(r));\r\n      if (nameMatchesRace) {\r\n        const parentDepth = prop.ancestors ? prop.ancestors.length : 0;\r\n        if (parentDepth <= 2) {\r\n          race = prop.name;\r\n          raceFound = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for race property types\r\n    if (!raceFound && (prop.type === 'race' || prop.type === 'species' || prop.type === 'characterRace')) {\r\n      if (prop.name) {\r\n        race = prop.name;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // DiceCloud v2 stores race as a constant\r\n    if (!raceFound && prop.type === 'constant' && prop.name && prop.name.toLowerCase() === 'race') {\r\n      if (prop.value) {\r\n        race = prop.value;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    if (prop.type === 'class' && prop.name && !prop.inactive && !prop.disabled) {\r\n      const cleanName = prop.name.replace(/\\s*\\[Multiclass\\]/i, '').trim();\r\n      const normalizedClassName = cleanName.toLowerCase().trim();\r\n      if (!uniqueClasses.has(normalizedClassName)) {\r\n        uniqueClasses.add(normalizedClassName);\r\n        characterClass = characterClass ? `${characterClass} / ${cleanName}` : cleanName;\r\n      }\r\n    }\r\n\r\n    if (prop.type === 'classLevel' && !prop.inactive && !prop.disabled) {\r\n      level += 1;\r\n    }\r\n  }\r\n\r\n  // Fallback: Check for race in variables if not found in properties\r\n  if (!raceFound && (!race || race === 'Unknown')) {\r\n    const raceVars = Object.keys(variables).filter(key =>\r\n      key.toLowerCase().includes('race') || key.toLowerCase().includes('species')\r\n    );\r\n\r\n    if (raceVars.length > 0) {\r\n      // Log raw data for each race variable\r\n      raceVars.forEach(varName => {\r\n        console.log(`parseForRollCloud: Raw data for \"${varName}\":`, variables[varName]);\r\n      });\r\n\r\n      // Helper function to format camelCase race names\r\n      const formatRaceName = (name) => {\r\n        if (!name) return null;\r\n        if (name.toLowerCase() === 'custom' || name.toLowerCase() === 'customlineage') {\r\n          return 'Custom Lineage';\r\n        }\r\n        let formatted = name.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n        formatted = formatted.split(' ').map(word =>\r\n          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n        ).join(' ');\r\n        return formatted;\r\n      };\r\n\r\n      // Helper function to extract race name from variable name\r\n      const extractRaceFromVarName = (varName) => {\r\n        const raceName = varName.replace(/race$/i, '').replace(/^race$/i, '');\r\n        if (raceName && raceName !== varName.toLowerCase()) {\r\n          return raceName.charAt(0).toUpperCase() + raceName.slice(1);\r\n        }\r\n        return null;\r\n      };\r\n\r\n      let raceName = null;\r\n      let subraceName = null;\r\n\r\n      // Check for subRace first\r\n      const subRaceVar = raceVars.find(key => key.toLowerCase() === 'subrace');\r\n      if (subRaceVar) {\r\n        const subRaceValue = variables[subRaceVar];\r\n        if (typeof subRaceValue === 'object' && subRaceValue !== null) {\r\n          if (subRaceValue.name) {\r\n            subraceName = formatRaceName(subRaceValue.name);\r\n          } else if (subRaceValue.text) {\r\n            subraceName = formatRaceName(subRaceValue.text);\r\n          } else if (subRaceValue.value) {\r\n            subraceName = formatRaceName(subRaceValue.value);\r\n          }\r\n        } else if (typeof subRaceValue === 'string') {\r\n          subraceName = formatRaceName(subRaceValue);\r\n        }\r\n      }\r\n\r\n      // Check for race variable\r\n      const raceVar = raceVars.find(key => key.toLowerCase() === 'race');\r\n      if (raceVar) {\r\n        const raceValue = variables[raceVar];\r\n        if (typeof raceValue === 'object' && raceValue !== null) {\r\n          // Check for nested value.value (DiceCloud constants have this structure)\r\n          if (raceValue.value && typeof raceValue.value === 'object' && raceValue.value.value) {\r\n            raceName = formatRaceName(raceValue.value.value);\r\n          } else if (raceValue.value && typeof raceValue.value === 'string') {\r\n            raceName = formatRaceName(raceValue.value);\r\n          } else if (raceValue.name) {\r\n            raceName = formatRaceName(raceValue.name);\r\n          } else if (raceValue.text) {\r\n            raceName = formatRaceName(raceValue.text);\r\n          }\r\n        } else if (typeof raceValue === 'string') {\r\n          raceName = formatRaceName(raceValue);\r\n        }\r\n      }\r\n\r\n      // If we didn't find race/subrace with names, look for specific race variables\r\n      if (!raceName) {\r\n        for (const varName of raceVars) {\r\n          const varValue = variables[varName];\r\n          if (typeof varValue === 'object' && varValue !== null && varValue.value === true) {\r\n            const extracted = extractRaceFromVarName(varName);\r\n            if (extracted) {\r\n              raceName = extracted;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Combine race and subrace if we have both\r\n      if (raceName && subraceName) {\r\n        race = `${raceName} - ${subraceName}`;\r\n      } else if (subraceName) {\r\n        race = subraceName;\r\n      } else if (raceName) {\r\n        race = raceName;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Build attributes\r\n  const attributes = {};\r\n  STANDARD_VARS.abilities.forEach(ability => {\r\n    attributes[ability] = variables[ability]?.total || variables[ability]?.value || 10;\r\n  });\r\n\r\n  // Calculate modifiers\r\n  const attributeMods = {};\r\n  Object.keys(attributes).forEach(attr => {\r\n    attributeMods[attr] = Math.floor((attributes[attr] - 10) / 2);\r\n  });\r\n\r\n  // Extract saves\r\n  const saves = {};\r\n  STANDARD_VARS.saves.forEach(save => {\r\n    if (variables[save]) {\r\n      const abilityName = save.replace('Save', '');\r\n      saves[abilityName] = variables[save].total || variables[save].value || 0;\r\n    }\r\n  });\r\n\r\n  // Extract skills\r\n  const skills = {};\r\n  STANDARD_VARS.skills.forEach(skill => {\r\n    if (variables[skill]) {\r\n      skills[skill] = variables[skill].total || variables[skill].value || 0;\r\n    }\r\n  });\r\n\r\n  // Calculate AC using the comprehensive logic\r\n  const calculateAC = () => {\r\n    const extractNumeric = (val) => {\r\n      if (val === null || val === undefined) return null;\r\n      if (typeof val === 'number' && !isNaN(val)) return val;\r\n      if (typeof val === 'string') {\r\n        const parsed = parseFloat(val);\r\n        return isNaN(parsed) ? null : parsed;\r\n      }\r\n      if (typeof val === 'object') {\r\n        if (val.total !== undefined && typeof val.total === 'number') return val.total;\r\n        if (val.value !== undefined && typeof val.value === 'number') return val.value;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    if (variables.armorClass?.total || variables.armorClass?.value) {\r\n      return variables.armorClass.total || variables.armorClass.value;\r\n    }\r\n\r\n    if (creature.denormalizedStats) {\r\n      const tryKeys = ['armorClass', 'ac', 'armor'];\r\n      for (const k of tryKeys) {\r\n        if (creature.denormalizedStats.hasOwnProperty(k)) {\r\n          const num = extractNumeric(creature.denormalizedStats[k]);\r\n          if (num !== null) return num;\r\n        }\r\n      }\r\n    }\r\n\r\n    const varNamesToCheck = ['armor', 'armorClass', 'armor_class', 'ac', 'acTotal'];\r\n    for (const vn of varNamesToCheck) {\r\n      if (variables.hasOwnProperty(vn)) {\r\n        const candidate = extractNumeric(variables[vn]?.total ?? variables[vn]?.value ?? variables[vn]);\r\n        if (candidate !== null) return candidate;\r\n      }\r\n    }\r\n\r\n    let baseAC = 10;\r\n    let armorAC = null;\r\n    const acBonuses = [];\r\n\r\n    properties.forEach(prop => {\r\n      if (prop.inactive || prop.disabled) return;\r\n\r\n      const hasArmorStat = prop.stat === 'armor' || (Array.isArray(prop.stats) && prop.stats.includes('armor'));\r\n\r\n      if (hasArmorStat) {\r\n        let amount = typeof prop.amount === 'number' ? prop.amount : parseFloat(prop.amount);\r\n        if (!isNaN(amount)) {\r\n          const operation = prop.operation || '';\r\n          if (operation === 'base' || operation === 'Base value') {\r\n            if (armorAC === null || amount > armorAC) armorAC = amount;\r\n          } else if (operation === 'add' || operation === 'Add') {\r\n            acBonuses.push({ name: prop.name, amount });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    let finalAC = armorAC !== null ? armorAC : baseAC;\r\n    acBonuses.forEach(bonus => finalAC += bonus.amount);\r\n    return finalAC;\r\n  };\r\n\r\n  return {\r\n    name: characterName,\r\n    race,\r\n    class: characterClass || 'Unknown',\r\n    level,\r\n    background: '',\r\n    alignment: creature.alignment || '',\r\n    attributes,\r\n    attributeMods,\r\n    saves,\r\n    skills,\r\n    hitPoints: {\r\n      current: variables.hitPoints?.currentValue ?? variables.hitPoints?.value ?? 0,\r\n      max: variables.hitPoints?.total ?? variables.hitPoints?.max ?? 0\r\n    },\r\n    temporaryHP: variables.temporaryHitPoints?.value ?? variables.temporaryHitPoints?.currentValue ?? 0,\r\n    armorClass: calculateAC(),\r\n    speed: variables.speed?.total || variables.speed?.value || 30,\r\n    initiative: variables.initiative?.total || variables.initiative?.value || 0,\r\n    proficiencyBonus: variables.proficiencyBonus?.total || variables.proficiencyBonus?.value || 0\r\n  };\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Owlbear Rodeo-specific format\r\n * Called by OwlCloud adapter when tab is loaded\r\n */\r\nexport function parseForOwlCloud(rawData) {\r\n  // For now, use same format as Roll20\r\n  return parseForRollCloud(rawData);\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Foundry VTT-specific format\r\n * Called by FoundCloud adapter when tab is loaded\r\n */\r\nexport function parseForFoundCloud(rawData) {\r\n  // For now, use same format as Roll20\r\n  // TODO: Customize for Foundry VTT's data structure\r\n  return parseForRollCloud(rawData);\r\n}\r\n", "/**\r\n * RollCloud Adapter\r\n * Roll20 integration for CarmaClouds\r\n * Loads the full RollCloud popup UI\r\n */\r\n\r\nimport { parseForRollCloud } from '../../../content/dicecloud-extraction.js';\r\n\r\nexport async function init(containerEl) {\r\n  console.log('Initializing RollCloud adapter...');\r\n\r\n  try {\r\n    // Show loading state\r\n    containerEl.innerHTML = '<div class=\"loading\">Loading RollCloud...</div>';\r\n\r\n    // Fetch synced characters from storage\r\n    const result = await chrome.storage.local.get('carmaclouds_characters');\r\n    const characters = result.carmaclouds_characters || [];\r\n\r\n    console.log('Found', characters.length, 'synced characters');\r\n\r\n    // Get the most recent character (for now - later we'll add character selection)\r\n    const character = characters.length > 0 ? characters[0] : null;\r\n\r\n    let parsedData = null;\r\n    if (character && character.raw) {\r\n      // Parse raw DiceCloud data for Roll20\r\n      containerEl.innerHTML = '<div class=\"loading\">Parsing character data...</div>';\r\n\r\n      console.log('Parsing character for Roll20:', character.name);\r\n      parsedData = parseForRollCloud(character.raw);\r\n      console.log('Parsed data:', parsedData);\r\n    }\r\n\r\n    // Fetch the RollCloud popup HTML\r\n    const htmlPath = chrome.runtime.getURL('src/popup/adapters/rollcloud/popup.html');\r\n    const response = await fetch(htmlPath);\r\n    const html = await response.text();\r\n\r\n    // Extract only the main content (not the full HTML document with header/footer)\r\n    const parser = new DOMParser();\r\n    const doc = parser.parseFromString(html, 'text/html');\r\n    const mainContent = doc.querySelector('main');\r\n\r\n    // Wrap content in a scoped container to prevent CSS conflicts\r\n    const wrapper = document.createElement('div');\r\n    wrapper.className = 'rollcloud-adapter-scope';\r\n    wrapper.innerHTML = mainContent ? mainContent.innerHTML : doc.body.innerHTML;\r\n    containerEl.innerHTML = '';\r\n    containerEl.appendChild(wrapper);\r\n\r\n    // Load and inject the CSS with scoping\r\n    const cssPath = chrome.runtime.getURL('src/popup/adapters/rollcloud/popup.css');\r\n    const cssResponse = await fetch(cssPath);\r\n    let css = await cssResponse.text();\r\n\r\n    // Scope all CSS rules to the adapter container\r\n    css = css.replace(/(^|\\})\\s*([^{}@]+)\\s*\\{/gm, (match, closer, selector) => {\r\n      // Don't scope @media, @keyframes, etc.\r\n      if (selector.trim().startsWith('@')) return match;\r\n      // Scope the selector\r\n      const scopedSelector = selector.split(',').map(s => `.rollcloud-adapter-scope ${s.trim()}`).join(', ');\r\n      return `${closer} ${scopedSelector} {`;\r\n    });\r\n\r\n    const style = document.createElement('style');\r\n    style.textContent = css;\r\n    containerEl.appendChild(style);\r\n\r\n    // Populate character info directly if we have data\r\n    if (parsedData && character) {\r\n      // Show character info card\r\n      const characterInfo = wrapper.querySelector('#characterInfo');\r\n      const statusSection = wrapper.querySelector('#status');\r\n\r\n      if (characterInfo) {\r\n        characterInfo.classList.remove('hidden');\r\n\r\n        // Populate character fields\r\n        const nameEl = characterInfo.querySelector('#charName');\r\n        const levelEl = characterInfo.querySelector('#charLevel');\r\n        const classEl = characterInfo.querySelector('#charClass');\r\n        const raceEl = characterInfo.querySelector('#charRace');\r\n\r\n        if (nameEl) nameEl.textContent = character.name || '-';\r\n        if (levelEl) levelEl.textContent = character.preview?.level || '-';\r\n        if (classEl) classEl.textContent = character.preview?.class || '-';\r\n        if (raceEl) raceEl.textContent = character.preview?.race || 'Unknown';\r\n\r\n        // Add push to VTT button handler\r\n        const pushBtn = characterInfo.querySelector('#pushToVttBtn');\r\n        if (pushBtn) {\r\n          pushBtn.addEventListener('click', async () => {\r\n            const originalText = pushBtn.innerHTML;\r\n            try {\r\n              pushBtn.disabled = true;\r\n              pushBtn.innerHTML = '\u23F3 Pushing...';\r\n\r\n              // Get the active Roll20 tab\r\n              const tabs = await chrome.tabs.query({ url: '*://app.roll20.net/*' });\r\n              if (tabs.length === 0) {\r\n                throw new Error('No Roll20 tab found. Please open Roll20 first.');\r\n              }\r\n\r\n              // Send character data to Roll20 content script\r\n              await chrome.tabs.sendMessage(tabs[0].id, {\r\n                type: 'PUSH_CHARACTER',\r\n                data: parsedData\r\n              });\r\n\r\n              pushBtn.innerHTML = '\u2705 Pushed!';\r\n              setTimeout(() => {\r\n                pushBtn.innerHTML = originalText;\r\n                pushBtn.disabled = false;\r\n              }, 2000);\r\n            } catch (error) {\r\n              console.error('Error pushing to Roll20:', error);\r\n              pushBtn.innerHTML = '\u274C Failed';\r\n              alert(`Failed to push to Roll20: ${error.message}`);\r\n              setTimeout(() => {\r\n                pushBtn.innerHTML = originalText;\r\n                pushBtn.disabled = false;\r\n              }, 2000);\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update status to show success\r\n      if (statusSection) {\r\n        const statusIcon = statusSection.querySelector('#statusIcon');\r\n        const statusText = statusSection.querySelector('#statusText');\r\n        if (statusIcon) statusIcon.textContent = '\u2705';\r\n        if (statusText) statusText.textContent = `Character synced: ${character.name}`;\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Failed to load RollCloud UI:', error);\r\n    containerEl.innerHTML = `\r\n      <div class=\"error\">\r\n        <strong>Failed to load RollCloud</strong>\r\n        <p>${error.message}</p>\r\n      </div>\r\n    `;\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["raceName"]
}
