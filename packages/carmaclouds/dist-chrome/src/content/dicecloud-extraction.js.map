{
  "version": 3,
  "sources": ["../../../src/content/dicecloud-extraction.js"],
  "sourcesContent": ["/**\r\n * Comprehensive DiceCloud character data extraction\r\n * Copied from proven OwlCloud implementation\r\n */\r\n\r\n// Standardized DiceCloud variable names\r\nconst STANDARD_VARS = {\r\n  abilities: ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'],\r\n  abilityMods: ['strengthMod', 'dexterityMod', 'constitutionMod', 'intelligenceMod', 'wisdomMod', 'charismaMod'],\r\n  saves: ['strengthSave', 'dexteritySave', 'constitutionSave', 'intelligenceSave', 'wisdomSave', 'charismaSave'],\r\n  skills: [\r\n    'acrobatics', 'animalHandling', 'arcana', 'athletics', 'deception', 'history',\r\n    'insight', 'intimidation', 'investigation', 'medicine', 'nature', 'perception',\r\n    'performance', 'persuasion', 'religion', 'sleightOfHand', 'stealth', 'survival'\r\n  ],\r\n  combat: ['armorClass', 'hitPoints', 'speed', 'initiative', 'proficiencyBonus']\r\n};\r\n\r\n/**\r\n * Validates if a property should be included (compensates for DiceCloud API cache issues)\r\n * Returns false for inactive, disabled, or likely-deleted items\r\n */\r\nfunction isValidProperty(property) {\r\n  if (!property) return false;\r\n\r\n  // Filter out explicitly inactive or disabled items\r\n  if (property.inactive === true || property.disabled === true) return false;\r\n\r\n  // Filter out removed items (DiceCloud sometimes uses this flag)\r\n  if (property.removed === true || property.soft_removed === true) return false;\r\n\r\n  // Filter out items with null/undefined critical IDs (corrupted data)\r\n  if (!property._id && !property.id) return false;\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Normalizes a name for duplicate detection\r\n * Handles common variations: \"Use a d8 Hit Die\" vs \"Using a d8 Hit Dice\"\r\n */\r\nfunction normalizeNameForDedupe(name) {\r\n  if (!name) return '';\r\n\r\n  return name\r\n    .toLowerCase()\r\n    .trim()\r\n    // Remove common articles and prepositions\r\n    .replace(/\\b(a|an|the)\\b/g, '')\r\n    // Normalize verb forms (using -> use, adding -> add, etc)\r\n    .replace(/ing\\b/g, '')\r\n    // Normalize plurals (dice -> die, dies -> die)\r\n    .replace(/dice/g, 'die')\r\n    .replace(/ies\\b/g, 'y')\r\n    .replace(/s\\b/g, '')\r\n    // Remove all non-alphanumeric except spaces\r\n    .replace(/[^a-z0-9\\s]/g, '')\r\n    // Collapse multiple spaces\r\n    .replace(/\\s+/g, ' ')\r\n    .trim();\r\n}\r\n\r\n/**\r\n * Deduplicates an array of items based on normalized name similarity\r\n * Keeps the first occurrence of each unique normalized name\r\n */\r\nfunction deduplicateByName(items) {\r\n  const seen = new Set();\r\n  return items.filter(item => {\r\n    const normalized = normalizeNameForDedupe(item.name);\r\n    if (seen.has(normalized)) {\r\n      return false; // Skip duplicate\r\n    }\r\n    seen.add(normalized);\r\n    return true;\r\n  });\r\n}\r\n\r\n/**\r\n * Evaluates DiceCloud conditional expressions in text\r\n * Handles patterns like: [variable > 1 ? \"text\" : \"\"] or [variable ? \"text\" : \"\"]\r\n * @param {string} text - Text potentially containing conditionals\r\n * @param {object} variables - DiceCloud variables object for evaluation\r\n * @returns {string} Text with conditionals evaluated or cleaned\r\n */\r\nfunction evaluateConditionals(text, variables = {}) {\r\n  if (!text || typeof text !== 'string') return text;\r\n\r\n  // Match DiceCloud conditional syntax: [condition ? \"text\" : \"fallback\"]\r\n  // Supports nested quotes and multiple conditions\r\n  const conditionalPattern = /\\[([^\\[\\]]+)\\s*\\?\\s*\"([^\"]*)\"\\s*:\\s*\"([^\"]*)\"\\]/g;\r\n\r\n  let result = text;\r\n  let match;\r\n\r\n  while ((match = conditionalPattern.exec(text)) !== null) {\r\n    const fullMatch = match[0];\r\n    const condition = match[1].trim();\r\n    const trueText = match[2];\r\n    const falseText = match[3];\r\n\r\n    // Try to evaluate the condition\r\n    let shouldShow = false;\r\n\r\n    // Handle comparison operators: >, <, >=, <=, ==, !=\r\n    const comparisonMatch = condition.match(/^(\\w+)\\s*(>|<|>=|<=|==|!=)\\s*(.+)$/);\r\n    if (comparisonMatch) {\r\n      const varName = comparisonMatch[1];\r\n      const operator = comparisonMatch[2];\r\n      const compareValue = comparisonMatch[3].trim();\r\n\r\n      // Get variable value (case-sensitive first, then try lowercase)\r\n      let varValue = variables[varName];\r\n      if (varValue === undefined) {\r\n        varValue = variables[varName.toLowerCase()];\r\n      }\r\n\r\n      // Convert to number if possible\r\n      const numVarValue = parseFloat(varValue);\r\n      const numCompareValue = parseFloat(compareValue);\r\n\r\n      if (!isNaN(numVarValue) && !isNaN(numCompareValue)) {\r\n        switch (operator) {\r\n          case '>': shouldShow = numVarValue > numCompareValue; break;\r\n          case '<': shouldShow = numVarValue < numCompareValue; break;\r\n          case '>=': shouldShow = numVarValue >= numCompareValue; break;\r\n          case '<=': shouldShow = numVarValue <= numCompareValue; break;\r\n          case '==': shouldShow = numVarValue === numCompareValue; break;\r\n          case '!=': shouldShow = numVarValue !== numCompareValue; break;\r\n        }\r\n      } else {\r\n        // String comparison fallback\r\n        switch (operator) {\r\n          case '==': shouldShow = varValue == compareValue; break;\r\n          case '!=': shouldShow = varValue != compareValue; break;\r\n        }\r\n      }\r\n    } else {\r\n      // Simple boolean check (variable exists and is truthy)\r\n      const varName = condition;\r\n      let varValue = variables[varName];\r\n      if (varValue === undefined) {\r\n        varValue = variables[varName.toLowerCase()];\r\n      }\r\n\r\n      // Check if truthy (non-zero, non-empty, true)\r\n      shouldShow = !!(varValue && varValue !== 0 && varValue !== '0' && varValue !== false);\r\n    }\r\n\r\n    // Replace the conditional with the appropriate text\r\n    result = result.replace(fullMatch, shouldShow ? trueText : falseText);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Evaluates and cleans damage formulas by substituting variables\r\n * Handles DiceCloud formula syntax like: 1d10 + floor((level+1)/6)d10\r\n * @param {string} formula - Damage formula potentially containing variables\r\n * @param {object} variables - DiceCloud variables object for evaluation\r\n * @returns {string} Formula with variables evaluated\r\n */\r\nfunction evaluateDamageFormula(formula, variables = {}) {\r\n  if (!formula || typeof formula !== 'string') return formula;\r\n\r\n  let result = formula;\r\n\r\n  // Helper to get variable value (case-insensitive)\r\n  const getVar = (name) => {\r\n    if (!name) return undefined;\r\n    // Try exact case first\r\n    if (variables[name] !== undefined) {\r\n      return variables[name];\r\n    }\r\n    // Try lowercase\r\n    const lower = name.toLowerCase();\r\n    if (variables[lower] !== undefined) {\r\n      return variables[lower];\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  // Replace variable references with their values\r\n  // Match word boundaries to avoid partial replacements\r\n  const variablePattern = /\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b/g;\r\n\r\n  result = result.replace(variablePattern, (match, varName) => {\r\n    // Don't replace dice notation (d followed by numbers)\r\n    if (varName === 'd' || varName === 'D') return match;\r\n\r\n    // Don't replace common math functions\r\n    if (['floor', 'ceil', 'round', 'abs', 'min', 'max'].includes(varName.toLowerCase())) {\r\n      return match;\r\n    }\r\n\r\n    const value = getVar(varName);\r\n    if (value !== undefined) {\r\n      // Convert to number if possible\r\n      const numValue = parseFloat(value);\r\n      return isNaN(numValue) ? match : String(numValue);\r\n    }\r\n\r\n    return match;\r\n  });\r\n\r\n  // Evaluate mathematical expressions safely\r\n  try {\r\n    // Only evaluate if the formula contains parentheses or operators (not just dice notation)\r\n    if (/[\\(\\)\\+\\-\\*\\/]/.test(result)) {\r\n      // Replace floor/ceil/round with Math equivalents for evaluation\r\n      let evalFormula = result\r\n        .replace(/\\bfloor\\s*\\(/gi, 'Math.floor(')\r\n        .replace(/\\bceil\\s*\\(/gi, 'Math.ceil(')\r\n        .replace(/\\bround\\s*\\(/gi, 'Math.round(')\r\n        .replace(/\\babs\\s*\\(/gi, 'Math.abs(')\r\n        .replace(/\\bmin\\s*\\(/gi, 'Math.min(')\r\n        .replace(/\\bmax\\s*\\(/gi, 'Math.max(');\r\n\r\n      // Extract dice notation parts to preserve them\r\n      const diceParts = [];\r\n      evalFormula = evalFormula.replace(/(\\d+)d(\\d+)/gi, (match) => {\r\n        diceParts.push(match);\r\n        return `__DICE${diceParts.length - 1}__`;\r\n      });\r\n\r\n      // Try to evaluate the non-dice parts\r\n      // Split by dice placeholders and evaluate each numeric part\r\n      const parts = evalFormula.split(/(__DICE\\d+__)/);\r\n      const evaluatedParts = parts.map(part => {\r\n        if (part.startsWith('__DICE')) {\r\n          const index = parseInt(part.match(/\\d+/)[0]);\r\n          return diceParts[index];\r\n        }\r\n\r\n        // Try to evaluate as math expression\r\n        try {\r\n          // Only evaluate if it's a pure math expression (no letters except Math functions)\r\n          if (!/[a-zA-Z]/.test(part.replace(/Math\\.(floor|ceil|round|abs|min|max)/g, ''))) {\r\n            const evaluated = eval(part);\r\n            if (!isNaN(evaluated) && isFinite(evaluated)) {\r\n              return String(evaluated);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          // If evaluation fails, return original\r\n        }\r\n\r\n        return part;\r\n      });\r\n\r\n      result = evaluatedParts.join('');\r\n    }\r\n  } catch (e) {\r\n    // If evaluation fails, return the variable-substituted version\r\n    console.warn('Failed to evaluate damage formula:', formula, e);\r\n  }\r\n\r\n  // Clean up any malformed syntax\r\n  result = result\r\n    .replace(/\\)\\s*d\\s*s/gi, 'd10')  // Fix \")ds\" artifacts\r\n    .replace(/\\(\\s*\\)/g, '')  // Remove empty parentheses\r\n    .replace(/\\+\\s*\\+/g, '+')  // Fix double plus signs\r\n    .replace(/\\s+/g, ' ')  // Normalize whitespace\r\n    .trim();\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Determines hit die type from character class (D&D 5e)\r\n */\r\nfunction getHitDieTypeFromClass(levels) {\r\n  const hitDiceMap = {\r\n    'barbarian': 'd12',\r\n    'fighter': 'd10',\r\n    'paladin': 'd10',\r\n    'ranger': 'd10',\r\n    'bard': 'd8',\r\n    'cleric': 'd8',\r\n    'druid': 'd8',\r\n    'monk': 'd8',\r\n    'rogue': 'd8',\r\n    'warlock': 'd8',\r\n    'sorcerer': 'd6',\r\n    'wizard': 'd6'\r\n  };\r\n\r\n  if (levels && levels.length > 0) {\r\n    const primaryClass = levels[0]?.name?.toLowerCase() || '';\r\n    for (const [classKey, die] of Object.entries(hitDiceMap)) {\r\n      if (primaryClass.includes(classKey)) {\r\n        return die;\r\n      }\r\n    }\r\n  }\r\n\r\n  return 'd8'; // Default\r\n}\r\n\r\n/**\r\n * Parses API response into structured character data\r\n */\r\nexport function parseCharacterData(apiData, characterId) {\r\n  console.log('CarmaClouds: Parsing character data...');\r\n\r\n  if (!apiData.creatures || apiData.creatures.length === 0) {\r\n    console.error('CarmaClouds: No creatures found in API response');\r\n    throw new Error('No character data found in API response');\r\n  }\r\n\r\n  const creature = apiData.creatures[0];\r\n  const variables = (apiData.creatureVariables && apiData.creatureVariables[0]) || {};\r\n  const properties = apiData.creatureProperties || [];\r\n\r\n  console.log('CarmaClouds: Creature:', creature.name);\r\n  console.log('CarmaClouds: Variables count:', Object.keys(variables).length);\r\n  console.log('CarmaClouds: Properties count:', properties.length);\r\n\r\n  // Extract character name early to ensure proper scope\r\n  const characterName = creature.name || '';\r\n\r\n  // Calculate AC from multiple sources\r\n  const calculateArmorClass = () => {\r\n    // Helper: try to coerce a variety of shapes into a numeric AC\r\n    const extractNumeric = (val) => {\r\n      if (val === null || val === undefined) return null;\r\n      if (typeof val === 'number' && !isNaN(val)) return val;\r\n      if (typeof val === 'string') {\r\n        const parsed = parseFloat(val);\r\n        return isNaN(parsed) ? null : parsed;\r\n      }\r\n      if (typeof val === 'object') {\r\n        if (val.total !== undefined && typeof val.total === 'number') return val.total;\r\n        if (val.value !== undefined && typeof val.value === 'number') return val.value;\r\n        if (val.calculation && typeof val.calculation === 'string') {\r\n          const bm = val.calculation.match(/^(\\d+)/);\r\n          if (bm) return parseInt(bm[1]);\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n\r\n    // Check if Dicecloud provided a calculated AC (most reliable)\r\n    if (variables.armorClass && (variables.armorClass.total || variables.armorClass.value)) {\r\n      const variableAC = variables.armorClass.total || variables.armorClass.value;\r\n      console.log(`CarmaClouds: Using Dicecloud's calculated AC: ${variableAC}`);\r\n      return variableAC;\r\n    }\r\n\r\n    // Try denormalizedStats\r\n    if (creature && creature.denormalizedStats) {\r\n      const tryKeys = ['armorClass', 'ac', 'armor'];\r\n      for (const k of tryKeys) {\r\n        if (creature.denormalizedStats.hasOwnProperty(k)) {\r\n          const num = extractNumeric(creature.denormalizedStats[k]);\r\n          if (num !== null) {\r\n            console.log(`CarmaClouds: Using denormalizedStats.${k}:`, num);\r\n            return num;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check variables for AC\r\n    const varNamesToCheck = ['armor', 'armorClass', 'armor_class', 'ac', 'acTotal'];\r\n    for (const vn of varNamesToCheck) {\r\n      if (variables.hasOwnProperty(vn)) {\r\n        const v = variables[vn];\r\n        const candidate = extractNumeric(v && (v.total ?? v.value ?? v));\r\n        if (candidate !== null) {\r\n          console.log(`CarmaClouds: Using variable ${vn}:`, candidate);\r\n          return candidate;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate from properties (base + armor + bonuses)\r\n    let baseAC = 10;\r\n    let armorAC = null;\r\n    const acBonuses = [];\r\n\r\n    properties.forEach(prop => {\r\n      if (prop.inactive || prop.disabled) return;\r\n\r\n      const hasArmorStat = prop.stat === 'armor' ||\r\n                          (Array.isArray(prop.stats) && prop.stats.includes('armor'));\r\n\r\n      if (hasArmorStat) {\r\n        let amount = null;\r\n        if (typeof prop.amount === 'number') {\r\n          amount = prop.amount;\r\n        } else if (typeof prop.amount === 'string') {\r\n          amount = parseFloat(prop.amount);\r\n        }\r\n\r\n        if (amount !== null && !isNaN(amount)) {\r\n          const operation = prop.operation || '';\r\n\r\n          if (operation === 'base' || operation === 'Base value') {\r\n            if (armorAC === null || amount > armorAC) {\r\n              armorAC = amount;\r\n            }\r\n          } else if (operation === 'add' || operation === 'Add') {\r\n            acBonuses.push({ name: prop.name, amount });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    let finalAC = armorAC !== null ? armorAC : baseAC;\r\n    acBonuses.forEach(bonus => {\r\n      finalAC += bonus.amount;\r\n    });\r\n\r\n    console.log('CarmaClouds: Calculated AC:', finalAC);\r\n    return finalAC;\r\n  };\r\n\r\n  // Extract race, class, and level from properties\r\n  let characterRace = 'Unknown';\r\n  let characterClass = '';\r\n  let characterLevel = 0;\r\n  const uniqueClasses = new Set();\r\n  let raceFound = false;\r\n\r\n  console.log('CarmaClouds: Extracting basic character info...');\r\n\r\n  // Debug: Log all property types to help identify race\r\n  const propertyTypes = {};\r\n  properties.forEach(prop => {\r\n    if (prop && prop.type) {\r\n      propertyTypes[prop.type] = (propertyTypes[prop.type] || 0) + 1;\r\n    }\r\n  });\r\n  console.log('CarmaClouds: Property types in character:', propertyTypes);\r\n\r\n  // Check if race is stored directly on creature\r\n  if (creature.race) {\r\n    console.log('CarmaClouds: Found race on creature:', creature.race);\r\n    characterRace = creature.race;\r\n    raceFound = true;\r\n  }\r\n  if (creature.denormalizedStats && creature.denormalizedStats.race) {\r\n    console.log('CarmaClouds: Found race in denormalizedStats:', creature.denormalizedStats.race);\r\n    characterRace = creature.denormalizedStats.race;\r\n    raceFound = true;\r\n  }\r\n\r\n  for (const prop of properties) {\r\n    if (!prop) continue;\r\n\r\n    // Check for race as a folder (DiceCloud often stores races as folders)\r\n    // Look for folders with common race names at the top level\r\n    if (!raceFound && prop.type === 'folder' && prop.name) {\r\n      const commonRaces = ['half-elf', 'half-orc', 'dragonborn', 'tiefling', 'halfling', 'human', 'elf', 'dwarf', 'gnome', 'orc', 'goblin', 'kobold', 'warforged', 'tabaxi', 'kenku', 'aarakocra', 'genasi', 'aasimar', 'firbolg', 'goliath', 'triton', 'yuan-ti', 'tortle', 'lizardfolk', 'bugbear', 'hobgoblin', 'changeling', 'shifter', 'kalashtar'];\r\n      const nameMatchesRace = commonRaces.some(race => new RegExp(`\\\\b${race}\\\\b`, 'i').test(prop.name));\r\n      if (nameMatchesRace) {\r\n        const parentDepth = prop.ancestors ? prop.ancestors.length : 0;\r\n        if (parentDepth <= 2) { // Top-level or near top-level folder\r\n          console.log('CarmaClouds: Found race folder:', prop.name);\r\n          characterRace = prop.name;\r\n          raceFound = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract race for preview - check multiple possible types\r\n    if (!raceFound && (prop.type === 'race' || prop.type === 'species' || prop.type === 'characterRace')) {\r\n      if (prop.name) {\r\n        console.log('CarmaClouds: Found race property:', prop.type, prop.name);\r\n        characterRace = prop.name;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // Check if it's a constant named \"Race\" (DiceCloud v2 stores race as a constant)\r\n    if (!raceFound && prop.type === 'constant' && prop.name && prop.name.toLowerCase() === 'race') {\r\n      if (prop.value) {\r\n        console.log('CarmaClouds: Found race as constant:', prop.value);\r\n        characterRace = prop.value;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // Extract class for preview\r\n    if (prop.type === 'class' && prop.name && isValidProperty(prop)) {\r\n      const cleanName = prop.name.replace(/\\s*\\[Multiclass\\]/i, '').trim();\r\n      const normalizedClassName = cleanName.toLowerCase().trim();\r\n      if (!uniqueClasses.has(normalizedClassName)) {\r\n        uniqueClasses.add(normalizedClassName);\r\n        if (characterClass) {\r\n          characterClass += ` / ${cleanName}`;\r\n        } else {\r\n          characterClass = cleanName;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract level for preview\r\n    if (prop.type === 'classLevel' && !prop.inactive && !prop.disabled) {\r\n      characterLevel += 1;\r\n    }\r\n  }\r\n\r\n  // Fallback: Check for race in variables if not found in properties\r\n  if (!raceFound && (!characterRace || characterRace === 'Unknown')) {\r\n    console.log('CarmaClouds: Race not found in properties, checking variables...');\r\n    const raceVars = Object.keys(variables).filter(key =>\r\n      key.toLowerCase().includes('race') || key.toLowerCase().includes('species')\r\n    );\r\n\r\n    if (raceVars.length > 0) {\r\n      console.log('CarmaClouds: Found race-related variables:', raceVars);\r\n\r\n      // Log raw data for each race variable\r\n      raceVars.forEach(varName => {\r\n        console.log(`CarmaClouds: Raw data for \"${varName}\":`, variables[varName]);\r\n      });\r\n\r\n      // Helper function to format camelCase race names\r\n      const formatRaceName = (name) => {\r\n        if (!name) return null;\r\n        if (name.toLowerCase() === 'custom' || name.toLowerCase() === 'customlineage') {\r\n          return 'Custom Lineage';\r\n        }\r\n        let formatted = name.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n        formatted = formatted.split(' ').map(word =>\r\n          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n        ).join(' ');\r\n        return formatted;\r\n      };\r\n\r\n      // Helper function to extract race name from variable name\r\n      const extractRaceFromVarName = (varName) => {\r\n        const raceName = varName.replace(/race$/i, '').replace(/^race$/i, '');\r\n        if (raceName && raceName !== varName.toLowerCase()) {\r\n          return raceName.charAt(0).toUpperCase() + raceName.slice(1);\r\n        }\r\n        return null;\r\n      };\r\n\r\n      let raceName = null;\r\n      let subraceName = null;\r\n\r\n      // Check for subRace first\r\n      const subRaceVar = raceVars.find(key => key.toLowerCase() === 'subrace');\r\n      if (subRaceVar) {\r\n        const subRaceValue = variables[subRaceVar];\r\n        console.log('CarmaClouds: Found subRace variable:', subRaceValue);\r\n        if (typeof subRaceValue === 'object' && subRaceValue !== null) {\r\n          if (subRaceValue.name) {\r\n            subraceName = formatRaceName(subRaceValue.name);\r\n          } else if (subRaceValue.text) {\r\n            subraceName = formatRaceName(subRaceValue.text);\r\n          } else if (subRaceValue.value) {\r\n            subraceName = formatRaceName(subRaceValue.value);\r\n          }\r\n        } else if (typeof subRaceValue === 'string') {\r\n          subraceName = formatRaceName(subRaceValue);\r\n        }\r\n        \r\n        // Skip generic labels like \"Sub Race\" - they're not actual subraces\r\n        if (subraceName && subraceName.toLowerCase() === 'sub race') {\r\n          console.log('CarmaClouds: Skipping generic \"Sub Race\" label, looking for actual subrace...');\r\n          subraceName = null;\r\n        }\r\n      }\r\n      \r\n      // If no valid subrace found, look for specific subrace variables\r\n      if (!subraceName) {\r\n        const subraceKeywords = ['fire', 'water', 'air', 'earth', 'firegenasi', 'watergenasi', 'airgenasi', 'earthgenasi'];\r\n        for (const varName of raceVars) {\r\n          const varValue = variables[varName];\r\n          const varNameLower = varName.toLowerCase();\r\n          \r\n          // Check if variable name contains subrace keyword and has truthy value\r\n          if (subraceKeywords.some(kw => varNameLower.includes(kw))) {\r\n            const isActive = typeof varValue === 'boolean' ? varValue : \r\n                            (typeof varValue === 'object' && varValue !== null && varValue.value === true);\r\n            \r\n            if (isActive || varValue === true) {\r\n              // Extract subrace from variable name\r\n              if (varNameLower.includes('fire')) subraceName = 'Fire';\r\n              else if (varNameLower.includes('water')) subraceName = 'Water';\r\n              else if (varNameLower.includes('air')) subraceName = 'Air';\r\n              else if (varNameLower.includes('earth')) subraceName = 'Earth';\r\n              \r\n              if (subraceName) {\r\n                console.log('CarmaClouds: Found subrace from variable:', varName, '->', subraceName);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check for race variable\r\n      const raceVar = raceVars.find(key => key.toLowerCase() === 'race');\r\n      if (raceVar) {\r\n        const raceValue = variables[raceVar];\r\n        console.log('CarmaClouds: Found race variable:', raceValue);\r\n        if (typeof raceValue === 'object' && raceValue !== null) {\r\n          // Check for nested value.value (DiceCloud constants have this structure)\r\n          if (raceValue.value && typeof raceValue.value === 'object' && raceValue.value.value) {\r\n            raceName = formatRaceName(raceValue.value.value);\r\n            console.log('CarmaClouds: Extracted race from nested value.value:', raceName);\r\n          } else if (raceValue.value && typeof raceValue.value === 'string') {\r\n            raceName = formatRaceName(raceValue.value);\r\n          } else if (raceValue.name) {\r\n            raceName = formatRaceName(raceValue.name);\r\n          } else if (raceValue.text) {\r\n            raceName = formatRaceName(raceValue.text);\r\n          }\r\n        } else if (typeof raceValue === 'string') {\r\n          raceName = formatRaceName(raceValue);\r\n        }\r\n      }\r\n\r\n      // If we didn't find race/subrace with names, look for specific race variables\r\n      if (!raceName) {\r\n        for (const varName of raceVars) {\r\n          const varValue = variables[varName];\r\n          if (typeof varValue === 'object' && varValue !== null && varValue.value === true) {\r\n            const extracted = extractRaceFromVarName(varName);\r\n            if (extracted) {\r\n              raceName = extracted;\r\n              console.log('CarmaClouds: Extracted race from variable name:', varName, '->', raceName);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Combine race and subrace if we have both\r\n      if (raceName && subraceName) {\r\n        characterRace = `${raceName} - ${subraceName}`;\r\n        console.log('CarmaClouds: Combined race and subrace:', characterRace);\r\n      } else if (subraceName) {\r\n        characterRace = subraceName;\r\n        console.log('CarmaClouds: Using subrace as race:', characterRace);\r\n      } else if (raceName) {\r\n        characterRace = raceName;\r\n        console.log('CarmaClouds: Using race:', characterRace);\r\n      } else {\r\n        console.log('CarmaClouds: Could not determine race from variables');\r\n      }\r\n    } else {\r\n      console.log('CarmaClouds: No race variables found');\r\n    }\r\n  }\r\n\r\n  console.log('CarmaClouds: Character preview:', characterName, characterLevel, characterRace, characterClass);\r\n\r\n  // Store just raw data + metadata - parsing happens per-VTT when tabs load\r\n  const characterData = {\r\n    // Metadata\r\n    id: creature._id || characterId,\r\n    name: characterName,\r\n    url: window.location.href,\r\n    timestamp: new Date().toISOString(),\r\n    source: 'dicecloud',\r\n\r\n    // Preview info (for character lists, etc.)\r\n    preview: {\r\n      race: characterRace,\r\n      class: characterClass || 'Unknown',\r\n      level: characterLevel\r\n    },\r\n\r\n    // Raw DiceCloud API data - VTT adapters will parse this as needed\r\n    raw: {\r\n      creature: creature,\r\n      variables: variables,\r\n      properties: properties\r\n    }\r\n  };\r\n\r\n  console.log('CarmaClouds: Successfully stored character data:', characterData.name);\r\n  return characterData;\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Roll20-specific format\r\n * Called by RollCloud adapter when tab is loaded\r\n */\r\nexport function parseForRollCloud(rawData) {\r\n  if (!rawData || !rawData.creature || !rawData.variables || !rawData.properties) {\r\n    throw new Error('Invalid raw data format');\r\n  }\r\n\r\n  const { creature, variables, properties } = rawData;\r\n\r\n  // Extract character name early to ensure proper scope\r\n  const characterName = creature.name || '';\r\n\r\n  // Extract race, class, level\r\n  let race = 'Unknown';\r\n  let characterClass = '';\r\n  let level = 0;\r\n  const uniqueClasses = new Set();\r\n  let raceFound = false;\r\n\r\n  for (const prop of properties) {\r\n    if (!prop) continue;\r\n\r\n    // Check for race as a folder (DiceCloud often stores races as folders)\r\n    if (!raceFound && prop.type === 'folder' && prop.name) {\r\n      const commonRaces = ['half-elf', 'half-orc', 'dragonborn', 'tiefling', 'halfling', 'human', 'elf', 'dwarf', 'gnome', 'orc', 'goblin', 'kobold', 'warforged', 'tabaxi', 'kenku', 'aarakocra', 'genasi', 'aasimar', 'firbolg', 'goliath', 'triton', 'yuan-ti', 'tortle', 'lizardfolk', 'bugbear', 'hobgoblin', 'changeling', 'shifter', 'kalashtar'];\r\n      const nameMatchesRace = commonRaces.some(r => new RegExp(`\\\\b${r}\\\\b`, 'i').test(prop.name));\r\n      if (nameMatchesRace) {\r\n        const parentDepth = prop.ancestors ? prop.ancestors.length : 0;\r\n        if (parentDepth <= 2) {\r\n          race = prop.name;\r\n          raceFound = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for race property types\r\n    if (!raceFound && (prop.type === 'race' || prop.type === 'species' || prop.type === 'characterRace')) {\r\n      if (prop.name) {\r\n        race = prop.name;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    // DiceCloud v2 stores race as a constant\r\n    if (!raceFound && prop.type === 'constant' && prop.name && prop.name.toLowerCase() === 'race') {\r\n      if (prop.value) {\r\n        race = prop.value;\r\n        raceFound = true;\r\n      }\r\n    }\r\n\r\n    if (prop.type === 'class' && prop.name && isValidProperty(prop)) {\r\n      const cleanName = prop.name.replace(/\\s*\\[Multiclass\\]/i, '').trim();\r\n      const normalizedClassName = cleanName.toLowerCase().trim();\r\n      if (!uniqueClasses.has(normalizedClassName)) {\r\n        uniqueClasses.add(normalizedClassName);\r\n        characterClass = characterClass ? `${characterClass} / ${cleanName}` : cleanName;\r\n      }\r\n    }\r\n\r\n    if (prop.type === 'classLevel' && !prop.inactive && !prop.disabled) {\r\n      level += 1;\r\n    }\r\n  }\r\n\r\n  // Fallback: Check for race in variables if not found in properties\r\n  if (!raceFound && (!race || race === 'Unknown')) {\r\n    const raceVars = Object.keys(variables).filter(key =>\r\n      key.toLowerCase().includes('race') || key.toLowerCase().includes('species')\r\n    );\r\n\r\n    if (raceVars.length > 0) {\r\n      // Log raw data for each race variable\r\n      raceVars.forEach(varName => {\r\n        console.log(`parseForRollCloud: Raw data for \"${varName}\":`, variables[varName]);\r\n      });\r\n\r\n      // Helper function to format camelCase race names\r\n      const formatRaceName = (name) => {\r\n        if (!name) return null;\r\n        if (name.toLowerCase() === 'custom' || name.toLowerCase() === 'customlineage') {\r\n          return 'Custom Lineage';\r\n        }\r\n        let formatted = name.replace(/([a-z])([A-Z])/g, '$1 $2');\r\n        formatted = formatted.split(' ').map(word =>\r\n          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n        ).join(' ');\r\n        return formatted;\r\n      };\r\n\r\n      // Helper function to extract race name from variable name\r\n      const extractRaceFromVarName = (varName) => {\r\n        const raceName = varName.replace(/race$/i, '').replace(/^race$/i, '');\r\n        if (raceName && raceName !== varName.toLowerCase()) {\r\n          return raceName.charAt(0).toUpperCase() + raceName.slice(1);\r\n        }\r\n        return null;\r\n      };\r\n\r\n      let raceName = null;\r\n      let subraceName = null;\r\n\r\n      // Check for subRace first\r\n      const subRaceVar = raceVars.find(key => key.toLowerCase() === 'subrace');\r\n      if (subRaceVar) {\r\n        const subRaceValue = variables[subRaceVar];\r\n        if (typeof subRaceValue === 'object' && subRaceValue !== null) {\r\n          if (subRaceValue.name) {\r\n            subraceName = formatRaceName(subRaceValue.name);\r\n          } else if (subRaceValue.text) {\r\n            subraceName = formatRaceName(subRaceValue.text);\r\n          } else if (subRaceValue.value) {\r\n            subraceName = formatRaceName(subRaceValue.value);\r\n          }\r\n        } else if (typeof subRaceValue === 'string') {\r\n          subraceName = formatRaceName(subRaceValue);\r\n        }\r\n      }\r\n\r\n      // Check for race variable\r\n      const raceVar = raceVars.find(key => key.toLowerCase() === 'race');\r\n      if (raceVar) {\r\n        const raceValue = variables[raceVar];\r\n        if (typeof raceValue === 'object' && raceValue !== null) {\r\n          // Check for nested value.value (DiceCloud constants have this structure)\r\n          if (raceValue.value && typeof raceValue.value === 'object' && raceValue.value.value) {\r\n            raceName = formatRaceName(raceValue.value.value);\r\n          } else if (raceValue.value && typeof raceValue.value === 'string') {\r\n            raceName = formatRaceName(raceValue.value);\r\n          } else if (raceValue.name) {\r\n            raceName = formatRaceName(raceValue.name);\r\n          } else if (raceValue.text) {\r\n            raceName = formatRaceName(raceValue.text);\r\n          }\r\n        } else if (typeof raceValue === 'string') {\r\n          raceName = formatRaceName(raceValue);\r\n        }\r\n      }\r\n\r\n      // If we didn't find race/subrace with names, look for specific race variables\r\n      if (!raceName) {\r\n        for (const varName of raceVars) {\r\n          const varValue = variables[varName];\r\n          if (typeof varValue === 'object' && varValue !== null && varValue.value === true) {\r\n            const extracted = extractRaceFromVarName(varName);\r\n            if (extracted) {\r\n              raceName = extracted;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Combine race and subrace if we have both\r\n      if (raceName && subraceName) {\r\n        race = `${raceName} - ${subraceName}`;\r\n      } else if (subraceName) {\r\n        race = subraceName;\r\n      } else if (raceName) {\r\n        race = raceName;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Build attributes\r\n  const attributes = {};\r\n  STANDARD_VARS.abilities.forEach(ability => {\r\n    attributes[ability] = variables[ability]?.total || variables[ability]?.value || 10;\r\n  });\r\n\r\n  // Calculate modifiers\r\n  const attributeMods = {};\r\n  Object.keys(attributes).forEach(attr => {\r\n    attributeMods[attr] = Math.floor((attributes[attr] - 10) / 2);\r\n  });\r\n\r\n  // Extract saves\r\n  const saves = {};\r\n  STANDARD_VARS.saves.forEach(save => {\r\n    if (variables[save]) {\r\n      const abilityName = save.replace('Save', '');\r\n      saves[abilityName] = variables[save].total || variables[save].value || 0;\r\n    }\r\n  });\r\n\r\n  // Extract skills\r\n  const skills = {};\r\n  STANDARD_VARS.skills.forEach(skill => {\r\n    if (variables[skill]) {\r\n      skills[skill] = variables[skill].total || variables[skill].value || 0;\r\n    }\r\n  });\r\n\r\n  // Calculate AC using the comprehensive logic\r\n  const calculateAC = () => {\r\n    const extractNumeric = (val) => {\r\n      if (val === null || val === undefined) return null;\r\n      if (typeof val === 'number' && !isNaN(val)) return val;\r\n      if (typeof val === 'string') {\r\n        const parsed = parseFloat(val);\r\n        return isNaN(parsed) ? null : parsed;\r\n      }\r\n      if (typeof val === 'object') {\r\n        if (val.total !== undefined && typeof val.total === 'number') return val.total;\r\n        if (val.value !== undefined && typeof val.value === 'number') return val.value;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    if (variables.armorClass?.total || variables.armorClass?.value) {\r\n      return variables.armorClass.total || variables.armorClass.value;\r\n    }\r\n\r\n    if (creature.denormalizedStats) {\r\n      const tryKeys = ['armorClass', 'ac', 'armor'];\r\n      for (const k of tryKeys) {\r\n        if (creature.denormalizedStats.hasOwnProperty(k)) {\r\n          const num = extractNumeric(creature.denormalizedStats[k]);\r\n          if (num !== null) return num;\r\n        }\r\n      }\r\n    }\r\n\r\n    const varNamesToCheck = ['armor', 'armorClass', 'armor_class', 'ac', 'acTotal'];\r\n    for (const vn of varNamesToCheck) {\r\n      if (variables.hasOwnProperty(vn)) {\r\n        const candidate = extractNumeric(variables[vn]?.total ?? variables[vn]?.value ?? variables[vn]);\r\n        if (candidate !== null) return candidate;\r\n      }\r\n    }\r\n\r\n    let baseAC = 10;\r\n    let armorAC = null;\r\n    const acBonuses = [];\r\n\r\n    properties.forEach(prop => {\r\n      if (prop.inactive || prop.disabled) return;\r\n\r\n      const hasArmorStat = prop.stat === 'armor' || (Array.isArray(prop.stats) && prop.stats.includes('armor'));\r\n\r\n      if (hasArmorStat) {\r\n        let amount = typeof prop.amount === 'number' ? prop.amount : parseFloat(prop.amount);\r\n        if (!isNaN(amount)) {\r\n          const operation = prop.operation || '';\r\n          if (operation === 'base' || operation === 'Base value') {\r\n            if (armorAC === null || amount > armorAC) armorAC = amount;\r\n          } else if (operation === 'add' || operation === 'Add') {\r\n            acBonuses.push({ name: prop.name, amount });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    let finalAC = armorAC !== null ? armorAC : baseAC;\r\n    acBonuses.forEach(bonus => finalAC += bonus.amount);\r\n    return finalAC;\r\n  };\r\n\r\n  // Helper to extract text from DiceCloud text objects and evaluate conditionals\r\n  const extractText = (field) => {\r\n    if (!field) return '';\r\n    let text = '';\r\n    if (typeof field === 'string') {\r\n      text = field;\r\n    } else if (typeof field === 'object' && field.text) {\r\n      text = field.text;\r\n    }\r\n    // Evaluate any conditional expressions using the character's variables\r\n    return evaluateConditionals(text, variables);\r\n  };\r\n\r\n  // Parse spells from properties with child attack/damage extraction (exclude inactive/disabled)\r\n  const spells = properties\r\n    .filter(p => p.type === 'spell' && isValidProperty(p))\r\n    .map(spell => {\r\n      // Find child properties (attack rolls, damage) for this spell\r\n      const spellChildren = properties.filter(p => {\r\n        if (p.type !== 'roll' && p.type !== 'damage' && p.type !== 'attack') return false;\r\n        if (p.ancestors && Array.isArray(p.ancestors)) {\r\n          return p.ancestors.some(ancestor => {\r\n            const ancestorId = typeof ancestor === 'object' ? ancestor.id : ancestor;\r\n            return ancestorId === spell._id;\r\n          });\r\n        }\r\n        return false;\r\n      });\r\n\r\n      // Extract attack roll from children\r\n      let attackRoll = '';\r\n      const attackChild = spellChildren.find(c => c.type === 'attack' || (c.type === 'roll' && c.name && c.name.toLowerCase().includes('attack')));\r\n      if (attackChild && attackChild.roll) {\r\n        if (typeof attackChild.roll === 'string') {\r\n          attackRoll = attackChild.roll;\r\n        } else if (typeof attackChild.roll === 'object') {\r\n          attackRoll = attackChild.roll.calculation || attackChild.roll.value || 'use_spell_attack_bonus';\r\n        }\r\n      }\r\n\r\n      // If no attack child found, check description for spell attack mentions\r\n      if (!attackRoll) {\r\n        const spellDescription = extractText(spell.description).toLowerCase();\r\n        const spellSummary = extractText(spell.summary).toLowerCase();\r\n        const fullText = `${spellDescription} ${spellSummary}`;\r\n\r\n        // Check for ranged or melee spell attack mentions\r\n        const hasSpellAttack = /\\b(ranged spell attack|melee spell attack|spell attack roll)\\b/.test(fullText);\r\n\r\n        if (hasSpellAttack) {\r\n          // Use special flag to indicate spell attack bonus should be used\r\n          attackRoll = 'use_spell_attack_bonus';\r\n          console.log(`\u2728 Detected spell attack in description for \"${spell.name}\", using spell attack bonus`);\r\n        }\r\n      }\r\n\r\n      // Evaluate variables in attack roll formula\r\n      if (attackRoll && attackRoll !== 'use_spell_attack_bonus') {\r\n        attackRoll = evaluateDamageFormula(attackRoll, variables);\r\n      }\r\n\r\n      // Extract damage rolls from children\r\n      const damageRolls = [];\r\n      spellChildren.filter(c => c.type === 'damage' || (c.type === 'roll' && c.name && (c.name.toLowerCase().includes('damage') || c.name.toLowerCase().includes('heal')))).forEach(damageChild => {\r\n        let formula = '';\r\n        // Try amount field first (standard damage property)\r\n        if (damageChild.amount) {\r\n          if (typeof damageChild.amount === 'string') {\r\n            formula = damageChild.amount;\r\n          } else if (typeof damageChild.amount === 'object') {\r\n            formula = damageChild.amount.calculation || String(damageChild.amount.value || '');\r\n          }\r\n        }\r\n        // Fallback to roll field (alternative structure)\r\n        else if (damageChild.roll) {\r\n          if (typeof damageChild.roll === 'string') {\r\n            formula = damageChild.roll;\r\n          } else if (typeof damageChild.roll === 'object') {\r\n            formula = damageChild.roll.calculation || String(damageChild.roll.value || '');\r\n          }\r\n        }\r\n        // Fallback to damage field\r\n        else if (damageChild.damage) {\r\n          if (typeof damageChild.damage === 'string') {\r\n            formula = damageChild.damage;\r\n          } else if (typeof damageChild.damage === 'object') {\r\n            formula = damageChild.damage.calculation || String(damageChild.damage.value || '');\r\n          }\r\n        }\r\n\r\n        if (formula) {\r\n          // Evaluate variables in damage formula\r\n          const evaluatedFormula = evaluateDamageFormula(formula, variables);\r\n          damageRolls.push({\r\n            formula: evaluatedFormula,\r\n            type: damageChild.damageType || '',\r\n            name: damageChild.name || ''\r\n          });\r\n        }\r\n      });\r\n\r\n      // First damage roll for backward compatibility\r\n      const damage = damageRolls.length > 0 ? damageRolls[0].formula : '';\r\n      const damageType = damageRolls.length > 0 ? damageRolls[0].type : '';\r\n\r\n      // Determine spell type (damage, healing, utility)\r\n      let spellType = 'utility';\r\n      if (damageRolls.length > 0) {\r\n        // Check if any damage roll is healing type\r\n        const hasHealingRoll = damageRolls.some(roll =>\r\n          roll.name.toLowerCase().includes('heal') ||\r\n          roll.type.toLowerCase().includes('heal')\r\n        );\r\n\r\n        // Also check spell name for healing keywords\r\n        const spellName = (spell.name || '').toLowerCase();\r\n        const hasHealingName = spellName.includes('heal') ||\r\n          spellName.includes('cure') ||\r\n          spellName.includes('regenerat') ||\r\n          spellName.includes('revivif') ||\r\n          spellName.includes('restoration') ||\r\n          spellName.includes('raise') ||\r\n          spellName.includes('resurrect');\r\n\r\n        // Check description for healing keywords\r\n        const spellDesc = extractText(spell.description).toLowerCase();\r\n        const hasHealingDesc = spellDesc.includes('regain') && spellDesc.includes('hit point');\r\n\r\n        spellType = (hasHealingRoll || hasHealingName || hasHealingDesc) ? 'healing' : 'damage';\r\n      }\r\n\r\n      // Detect lifesteal spells (damage + healing based on damage dealt)\r\n      // These spells have both a damage roll and a healing roll, where healing is based on damage\r\n      let isLifesteal = false;\r\n      if (damageRolls.length >= 2) {\r\n        const hasDamageRoll = damageRolls.some(roll =>\r\n          roll.type && roll.type.toLowerCase() !== 'healing'\r\n        );\r\n        const hasHealingRoll = damageRolls.some(roll =>\r\n          roll.type && roll.type.toLowerCase() === 'healing'\r\n        );\r\n\r\n        // Check if spell name or description indicates lifesteal\r\n        const spellName = (spell.name || '').toLowerCase();\r\n        const spellDesc = extractText(spell.description).toLowerCase();\r\n        const isVampiric = spellName.includes('vampiric') ||\r\n                          spellDesc.includes('regain') && spellDesc.includes('damage');\r\n\r\n        isLifesteal = hasDamageRoll && hasHealingRoll && isVampiric;\r\n      }\r\n\r\n      return {\r\n        id: spell._id,\r\n        name: spell.name || 'Unnamed Spell',\r\n        level: spell.level || 0,\r\n        school: spell.school || '',\r\n        spellType: spellType,\r\n        castingTime: spell.castingTime || '',\r\n        range: spell.range || '',\r\n        components: spell.components || '',\r\n        duration: spell.duration || '',\r\n        description: extractText(spell.description),\r\n        summary: extractText(spell.summary),\r\n        ritual: spell.ritual || false,\r\n        concentration: spell.concentration || false,\r\n        prepared: spell.prepared !== false,\r\n        alwaysPrepared: spell.alwaysPrepared || false,\r\n        attackRoll: attackRoll,\r\n        damage: damage,\r\n        damageType: damageType,\r\n        damageRolls: damageRolls,\r\n        isLifesteal: isLifesteal\r\n      };\r\n    });\r\n\r\n  // Parse actions from properties (exclude inactive/disabled)\r\n  const actions = properties\r\n    .filter(p => p.type === 'action' && p.name && isValidProperty(p))\r\n    .map(action => {\r\n      // Find child properties (attack rolls, damage) for this action\r\n      const actionChildren = properties.filter(p => {\r\n        if (p.type !== 'roll' && p.type !== 'damage' && p.type !== 'attack') return false;\r\n        if (p.ancestors && Array.isArray(p.ancestors)) {\r\n          return p.ancestors.some(ancestor => {\r\n            const ancestorId = typeof ancestor === 'object' ? ancestor.id : ancestor;\r\n            return ancestorId === action._id;\r\n          });\r\n        }\r\n        return false;\r\n      });\r\n\r\n      // Extract attack roll from action or children\r\n      let attackRoll = '';\r\n      if (action.attackRoll) {\r\n        attackRoll = typeof action.attackRoll === 'string' ? action.attackRoll : String(action.attackRoll.value || action.attackRoll.calculation || '');\r\n      } else {\r\n        // Check children for attack roll\r\n        const attackChild = actionChildren.find(c => c.type === 'attack' || (c.type === 'roll' && c.name && c.name.toLowerCase().includes('attack')));\r\n        if (attackChild && attackChild.roll) {\r\n          if (typeof attackChild.roll === 'string') {\r\n            attackRoll = attackChild.roll;\r\n          } else if (typeof attackChild.roll === 'object') {\r\n            attackRoll = attackChild.roll.calculation || attackChild.roll.value || '';\r\n          }\r\n        }\r\n      }\r\n\r\n      // Evaluate variables in attack roll formula\r\n      if (attackRoll) {\r\n        attackRoll = evaluateDamageFormula(attackRoll, variables);\r\n      }\r\n\r\n      // Extract damage from action or children\r\n      let damage = '';\r\n      let damageType = '';\r\n      if (action.damage) {\r\n        damage = typeof action.damage === 'string' ? action.damage : String(action.damage.value || action.damage.calculation || '');\r\n      } else {\r\n        // Check children for damage\r\n        const damageChild = actionChildren.find(c => c.type === 'damage' || (c.type === 'roll' && c.name && c.name.toLowerCase().includes('damage')));\r\n        if (damageChild) {\r\n          // Try amount field first (standard damage property)\r\n          if (damageChild.amount) {\r\n            if (typeof damageChild.amount === 'string') {\r\n              damage = damageChild.amount;\r\n            } else if (typeof damageChild.amount === 'object') {\r\n              damage = damageChild.amount.calculation || String(damageChild.amount.value || '');\r\n            }\r\n          }\r\n          // Fallback to roll field\r\n          else if (damageChild.roll) {\r\n            if (typeof damageChild.roll === 'string') {\r\n              damage = damageChild.roll;\r\n            } else if (typeof damageChild.roll === 'object') {\r\n              damage = damageChild.roll.calculation || String(damageChild.roll.value || '');\r\n            }\r\n          }\r\n          // Fallback to damage field\r\n          else if (damageChild.damage) {\r\n            if (typeof damageChild.damage === 'string') {\r\n              damage = damageChild.damage;\r\n            } else if (typeof damageChild.damage === 'object') {\r\n              damage = damageChild.damage.calculation || String(damageChild.damage.value || '');\r\n            }\r\n          }\r\n\r\n          // Extract damage type from child\r\n          if (damageChild.damageType) {\r\n            damageType = damageChild.damageType;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Evaluate variables in damage formula\r\n      if (damage) {\r\n        damage = evaluateDamageFormula(damage, variables);\r\n      }\r\n\r\n      // Check if this is a finesse weapon and add appropriate ability modifier to damage\r\n      if (damage && attackRoll) {\r\n        const tags = action.tags || [];\r\n        const description = extractText(action.description).toLowerCase();\r\n        const summary = extractText(action.summary).toLowerCase();\r\n\r\n        // Check if finesse weapon\r\n        const isFinesse = tags.some(t => typeof t === 'string' && t.toLowerCase().includes('finesse')) ||\r\n                          description.includes('finesse') ||\r\n                          summary.includes('finesse');\r\n\r\n        if (isFinesse) {\r\n          // Check if damage already includes an ability modifier\r\n          // Look for patterns like \"+X\" where X is a single/double digit number\r\n          const hasAbilityMod = /\\+\\s*\\d{1,2}(?!\\d)/.test(damage) || /dexterityMod|strengthMod|dexMod|strMod/i.test(damage);\r\n\r\n          if (!hasAbilityMod) {\r\n            // Get STR and DEX mods\r\n            const strMod = parseFloat(variables.strengthMod || variables.strengthmod || 0);\r\n            const dexMod = parseFloat(variables.dexterityMod || variables.dexteritymod || 0);\r\n\r\n            // Use higher of STR or DEX for finesse\r\n            const abilityMod = Math.max(strMod, dexMod);\r\n\r\n            if (abilityMod > 0) {\r\n              damage = `${damage} + ${abilityMod}`;\r\n            } else if (abilityMod < 0) {\r\n              damage = `${damage} - ${Math.abs(abilityMod)}`;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Fallback to action's damageType if not found in child\r\n      if (!damageType && action.damageType) {\r\n        damageType = action.damageType;\r\n      }\r\n\r\n      // Determine action type from tags or name\r\n      // Valid values: 'action', 'bonus', 'reaction', 'free' (must match filter buttons)\r\n      let actionType = 'action'; // default\r\n      const tags = action.tags || [];\r\n      const nameLower = (action.name || '').toLowerCase();\r\n      const summaryLower = extractText(action.summary).toLowerCase();\r\n      \r\n      // Check tags first (most reliable)\r\n      if (tags.some(t => typeof t === 'string' && t.toLowerCase().includes('bonus'))) {\r\n        actionType = 'bonus';\r\n      } else if (tags.some(t => typeof t === 'string' && t.toLowerCase().includes('reaction'))) {\r\n        actionType = 'reaction';\r\n      } else if (tags.some(t => typeof t === 'string' && t.toLowerCase().includes('free'))) {\r\n        actionType = 'free';\r\n      } else if (tags.some(t => typeof t === 'string' && (t.toLowerCase().includes('legendary') || t.toLowerCase().includes('lair')))) {\r\n        actionType = 'free'; // Legendary actions shown as free actions\r\n      } else if (tags.some(t => typeof t === 'string' && t.toLowerCase().includes('attack'))) {\r\n        actionType = 'action'; // Attacks are actions\r\n      }\r\n      // Check name/summary if tags didn't match\r\n      else if (nameLower.includes('bonus action') || summaryLower.includes('bonus action')) {\r\n        actionType = 'bonus';\r\n      } else if (nameLower.includes('reaction') || summaryLower.includes('reaction')) {\r\n        actionType = 'reaction';\r\n      } else if (nameLower.includes('free action') || summaryLower.includes('free action')) {\r\n        actionType = 'free';\r\n      } else if (attackRoll || damage) {\r\n        // Has attack or damage, likely an attack action\r\n        actionType = 'action';\r\n      }\r\n\r\n      return {\r\n        id: action._id,\r\n        name: action.name,\r\n        actionType: actionType,\r\n        description: extractText(action.description),\r\n        summary: extractText(action.summary),\r\n        attackRoll: attackRoll,\r\n        damage: damage,\r\n        damageType: damageType,\r\n        uses: action.uses || 0,\r\n        usesUsed: action.usesUsed || 0,\r\n        reset: action.reset || '',\r\n        resources: action.resources || {},\r\n        tags: action.tags || []\r\n      };\r\n    });\r\n\r\n  // Parse spell slots from variables\r\n  // DiceCloud uses: slotLevel1, slotLevel2, etc.\r\n  const spellSlots = {};\r\n  console.log('\uD83D\uDD2E Parsing spell slots from variables...');\r\n  console.log('\uD83D\uDD2E Available variables:', Object.keys(variables).filter(k => k.toLowerCase().includes('slot')));\r\n  for (let level = 1; level <= 9; level++) {\r\n    const slotVar = variables[`slotLevel${level}`];\r\n    if (slotVar) {\r\n      const current = slotVar.value || 0;\r\n      const max = slotVar.total || slotVar.max || slotVar.value || 0;\r\n      console.log(`\uD83D\uDD2E Level ${level} spell slots:`, { current, max, slotVar });\r\n      spellSlots[`level${level}`] = {\r\n        current: current,\r\n        max: max\r\n      };\r\n    }\r\n  }\r\n  console.log('\uD83D\uDD2E Final spell slots:', spellSlots);\r\n\r\n  // Parse resources from properties (only resource-type attributes)\r\n  const resources = properties\r\n    .filter(p => p.type === 'resource' || (p.type === 'attribute' && p.attributeType === 'resource'))\r\n    .map(resource => ({\r\n      id: resource._id,\r\n      name: resource.name || 'Unnamed Resource',\r\n      current: resource.value || resource.currentValue || 0,\r\n      max: resource.total || resource.max || 0,\r\n      reset: resource.reset || '',\r\n      variableName: resource.variableName || resource.varName || ''\r\n    }));\r\n\r\n  // Parse inventory from properties (items, equipment, and containers, exclude inactive)\r\n  const inventory = properties\r\n    .filter(p => (p.type === 'item' || p.type === 'equipment' || p.type === 'container') && isValidProperty(p))\r\n    .map(item => ({\r\n      id: item._id,\r\n      name: item.name || 'Unnamed Item',\r\n      quantity: item.quantity || 1,\r\n      weight: item.weight || 0,\r\n      value: item.value || 0,\r\n      description: extractText(item.description),\r\n      summary: extractText(item.summary),\r\n      equipped: item.equipped || false,\r\n      attuned: item.attuned || false,\r\n      requiresAttunement: item.requiresAttunement || false\r\n    }));\r\n\r\n  // Extract companions from features\r\n  const companions = extractCompanions(properties);\r\n\r\n  return {\r\n    name: characterName,\r\n    race,\r\n    class: characterClass || 'Unknown',\r\n    level,\r\n    background: '',\r\n    alignment: creature.alignment || '',\r\n    attributes,\r\n    attributeMods,\r\n    saves,\r\n    skills,\r\n    hitPoints: {\r\n      current: variables.hitPoints?.currentValue ?? variables.hitPoints?.value ?? 0,\r\n      max: variables.hitPoints?.total ?? variables.hitPoints?.max ?? 0\r\n    },\r\n    temporaryHP: variables.temporaryHitPoints?.value ?? variables.temporaryHitPoints?.currentValue ?? 0,\r\n    armorClass: calculateAC(),\r\n    speed: variables.speed?.total || variables.speed?.value || 30,\r\n    initiative: variables.initiative?.total || variables.initiative?.value || 0,\r\n    proficiencyBonus: variables.proficiencyBonus?.total || variables.proficiencyBonus?.value || 0,\r\n    spellSlots,\r\n    resources,\r\n    inventory: deduplicateByName(inventory),\r\n    spells: deduplicateByName(spells),\r\n    actions: deduplicateByName(actions),\r\n    companions\r\n  };\r\n}\r\n\r\n/**\r\n * Extract companions from properties (features with companion patterns)\r\n */\r\nfunction extractCompanions(properties) {\r\n  console.log('\uD83D\uDC3E Extracting companions from features...');\r\n  console.log('\uD83D\uDC3E Total properties to check:', properties.length);\r\n  \r\n  // Debug: Check what types of properties we have\r\n  const propertyTypes = new Set();\r\n  properties.forEach(p => {\r\n    if (p && p.type) propertyTypes.add(p.type);\r\n  });\r\n  console.log('\uD83D\uDC3E Property types available:', Array.from(propertyTypes).sort());\r\n  \r\n  const companionPatterns = [\r\n    /companion/i,\r\n    /beast of/i,\r\n    /familiar/i,\r\n    /summon/i,\r\n    /mount/i,\r\n    /steel defender/i,\r\n    /homunculus/i,\r\n    /drake/i,\r\n    /primal companion/i,\r\n    /beast master/i,\r\n    /ranger's companion/i\r\n  ];\r\n\r\n  const companions = [];\r\n  \r\n  // Check all properties, not just features - companions might be stored as actions, notes, or other types\r\n  const potentialCompanions = properties.filter(p => {\r\n    if (!p || !p.name || p.inactive) return false;\r\n    return companionPatterns.some(pattern => pattern.test(p.name));\r\n  });\r\n\r\n  console.log(`\uD83D\uDC3E Found ${potentialCompanions.length} properties matching companion patterns`);\r\n  potentialCompanions.forEach(prop => {\r\n    console.log(`\uD83D\uDC3E Potential companion: \"${prop.name}\" (type: ${prop.type})`);\r\n  });\r\n\r\n  const seenCompanions = new Set();\r\n  \r\n  potentialCompanions.forEach(feature => {\r\n    if (feature.description) {\r\n      console.log(`\uD83D\uDC3E Parsing companion: ${feature.name}`);\r\n      const companion = parseCompanionStatBlock(feature.name, feature.description);\r\n      if (companion) {\r\n        // Deduplicate by companion name\r\n        if (!seenCompanions.has(companion.name)) {\r\n          companions.push(companion);\r\n          seenCompanions.add(companion.name);\r\n          console.log(`\u2705 Added companion: ${companion.name}`);\r\n        } else {\r\n          console.log(`\u23ED\uFE0F Skipping duplicate companion: ${companion.name}`);\r\n        }\r\n      } else {\r\n        console.log(`\u26A0\uFE0F Failed to parse companion stat block for: ${feature.name}`);\r\n      }\r\n    } else {\r\n      console.log(`\u26A0\uFE0F No description for potential companion: ${feature.name}`);\r\n    }\r\n  });\r\n\r\n  console.log(`\uD83D\uDC3E Total companions found: ${companions.length} (after deduplication)`);\r\n  return companions;\r\n}\r\n\r\n/**\r\n * Parse companion stat block from description text\r\n */\r\nfunction parseCompanionStatBlock(name, description) {\r\n  let descText = typeof description === 'object' ? (description.value || description.text || '') : description;\r\n  \r\n  if (!descText || descText.trim() === '') return null;\r\n\r\n  const companion = {\r\n    name,\r\n    size: '',\r\n    type: '',\r\n    alignment: '',\r\n    ac: 0,\r\n    hp: '',\r\n    speed: '',\r\n    abilities: {},\r\n    senses: '',\r\n    languages: '',\r\n    proficiencyBonus: 0,\r\n    features: [],\r\n    actions: []\r\n  };\r\n\r\n  // Parse size/type (e.g., \"Small beast, neutral\")\r\n  const sizeTypeMatch = descText.match(/(Tiny|Small|Medium|Large|Huge|Gargantuan)\\s+(\\w+),\\s*(\\w+)/i);\r\n  if (sizeTypeMatch) {\r\n    companion.size = sizeTypeMatch[1];\r\n    companion.type = sizeTypeMatch[2];\r\n    companion.alignment = sizeTypeMatch[3];\r\n  }\r\n\r\n  // Parse AC\r\n  const acMatch = descText.match(/\\*\\*AC\\*\\*\\s+(\\d+)|AC\\s+(\\d+)/i);\r\n  if (acMatch) companion.ac = parseInt(acMatch[1] || acMatch[2]);\r\n\r\n  // Parse HP\r\n  const hpMatch = descText.match(/\\*\\*HP\\*\\*\\s+(\\d+\\s*\\([^)]+\\))|HP\\s+(\\d+\\s*\\([^)]+\\))/i);\r\n  if (hpMatch) companion.hp = hpMatch[1] || hpMatch[2];\r\n\r\n  // Parse Speed\r\n  const speedMatch = descText.match(/Speed\\s+([^\u2022\\n]+)/i);\r\n  if (speedMatch) companion.speed = speedMatch[1].trim();\r\n\r\n  // Parse Abilities from markdown table\r\n  const abilityLine = descText.match(/\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|\\s*(\\d+)\\s*\\(([+\\-]\\d+)\\)\\s*\\|/);\r\n  if (abilityLine) {\r\n    const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];\r\n    abilities.forEach((ability, i) => {\r\n      const scoreIdx = (i * 2) + 1;\r\n      const modIdx = (i * 2) + 2;\r\n      if (abilityLine[scoreIdx] && abilityLine[modIdx]) {\r\n        companion.abilities[ability] = {\r\n          score: parseInt(abilityLine[scoreIdx]),\r\n          modifier: parseInt(abilityLine[modIdx])\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  // Parse Senses\r\n  const sensesMatch = descText.match(/Senses\\s+([^\u2022\\n]+)/i);\r\n  if (sensesMatch) companion.senses = sensesMatch[1].trim();\r\n\r\n  // Parse Languages\r\n  const languagesMatch = descText.match(/Languages\\s+([^\u2022\\n]+)/i);\r\n  if (languagesMatch) companion.languages = languagesMatch[1].trim();\r\n\r\n  // Parse Proficiency Bonus\r\n  const pbMatch = descText.match(/Proficiency Bonus\\s+(\\d+)/i);\r\n  if (pbMatch) companion.proficiencyBonus = parseInt(pbMatch[1]);\r\n\r\n  // Parse Features (e.g., \"***Flyby.*** Description\")\r\n  const featurePattern = /\\*\\*\\*([^*\\n.]+)\\.\\*\\*\\*\\s*([^*\\n]+)/gi;\r\n  let featureMatch;\r\n  while ((featureMatch = featurePattern.exec(descText)) !== null) {\r\n    companion.features.push({\r\n      name: featureMatch[1].trim(),\r\n      description: featureMatch[2].trim()\r\n    });\r\n  }\r\n\r\n  // Parse Actions\r\n  const actionsMatch = descText.match(/###?\\s*Actions\\s+([\\s\\S]+)/i);\r\n  if (actionsMatch) {\r\n    const actionsText = actionsMatch[1];\r\n    const attackLines = actionsText.split('\\n').filter(line => line.includes('***') && line.includes('Melee Weapon Attack'));\r\n    \r\n    attackLines.forEach(attackLine => {\r\n      const nameMatch = attackLine.match(/\\*\\*\\*(\\w+)\\.\\*\\*\\*/);\r\n      const bonusMatch = attackLine.match(/\\*\\*(\\+\\d+)\\*\\*/);\r\n      const reachMatch = attackLine.match(/reach\\s*([\\d\\s]+ft\\.)/);\r\n      const damageMatch = attackLine.match(/\\*?Hit:\\*?\\s*\\*\\*([^*]+?)\\*\\*/);\r\n      \r\n      if (nameMatch && bonusMatch && reachMatch && damageMatch) {\r\n        companion.actions.push({\r\n          name: nameMatch[1].trim(),\r\n          type: 'attack',\r\n          attackBonus: parseInt(bonusMatch[1]),\r\n          reach: reachMatch[1].trim(),\r\n          damage: damageMatch[1].trim()\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Only return if we found at least some stats\r\n  if (companion.ac > 0 || companion.hp || Object.keys(companion.abilities).length > 0) {\r\n    return companion;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Owlbear Rodeo-specific format\r\n * Called by OwlCloud adapter when tab is loaded\r\n */\r\nexport function parseForOwlCloud(rawData) {\r\n  // For now, use same format as Roll20\r\n  return parseForRollCloud(rawData);\r\n}\r\n\r\n/**\r\n * Parse raw DiceCloud data into Foundry VTT-specific format\r\n * Maps to Foundry's D&D 5e system structure\r\n */\r\nexport function parseForFoundCloud(rawData, characterId = null) {\r\n  console.log('\uD83C\uDFB2 Parsing character for Foundry VTT...');\r\n\r\n  // First parse using RollCloud format to get standardized data\r\n  const rollCloudData = parseForRollCloud(rawData, characterId);\r\n\r\n  // Map to Foundry D&D 5e actor structure\r\n  const foundryData = {\r\n    // Basic info\r\n    id: characterId || rollCloudData.id,\r\n    name: rollCloudData.name,\r\n    type: 'character',\r\n    \r\n    // Attributes (abilities)\r\n    attributes: {\r\n      strength: rollCloudData.attributes?.strength || 10,\r\n      dexterity: rollCloudData.attributes?.dexterity || 10,\r\n      constitution: rollCloudData.attributes?.constitution || 10,\r\n      intelligence: rollCloudData.attributes?.intelligence || 10,\r\n      wisdom: rollCloudData.attributes?.wisdom || 10,\r\n      charisma: rollCloudData.attributes?.charisma || 10,\r\n      STR: rollCloudData.attributes?.strength || 10,\r\n      DEX: rollCloudData.attributes?.dexterity || 10,\r\n      CON: rollCloudData.attributes?.constitution || 10,\r\n      INT: rollCloudData.attributes?.intelligence || 10,\r\n      WIS: rollCloudData.attributes?.wisdom || 10,\r\n      CHA: rollCloudData.attributes?.charisma || 10\r\n    },\r\n\r\n    // Hit points\r\n    hit_points: {\r\n      current: rollCloudData.hitPoints?.current || 0,\r\n      max: rollCloudData.hitPoints?.max || 0\r\n    },\r\n\r\n    // Core stats\r\n    armor_class: rollCloudData.armorClass || 10,\r\n    speed: rollCloudData.speed || 30,\r\n    initiative: rollCloudData.initiative || 0,\r\n    proficiency_bonus: rollCloudData.proficiencyBonus || 2,\r\n\r\n    // Character details\r\n    level: rollCloudData.level || 1,\r\n    race: rollCloudData.race || 'Unknown',\r\n    class: rollCloudData.class || 'Unknown',\r\n    alignment: rollCloudData.alignment || '',\r\n    background: rollCloudData.background || '',\r\n\r\n    // Skills (map to Foundry format)\r\n    skills: rollCloudData.skills || {},\r\n\r\n    // Saves\r\n    saves: rollCloudData.saves || {},\r\n\r\n    // Death saves\r\n    death_saves: rollCloudData.deathSaves || { successes: 0, failures: 0 },\r\n\r\n    // Inspiration\r\n    inspiration: rollCloudData.inspiration || false,\r\n\r\n    // Temporary HP\r\n    temporary_hp: rollCloudData.hitPoints?.temp || 0,\r\n\r\n    // Spells (keep full spell data)\r\n    spells: rollCloudData.spells || [],\r\n    spell_slots: rollCloudData.spellSlots || {},\r\n\r\n    // Actions (keep full action data)\r\n    actions: rollCloudData.actions || [],\r\n\r\n    // Inventory\r\n    inventory: rollCloudData.inventory || [],\r\n\r\n    // Resources\r\n    resources: rollCloudData.resources || [],\r\n\r\n    // Companions\r\n    companions: rollCloudData.companions || [],\r\n\r\n    // Raw DiceCloud data for advanced features\r\n    raw_dicecloud_data: {\r\n      creature: rawData.creature || {},\r\n      variables: rawData.variables || {},\r\n      properties: rawData.properties || [],\r\n      picture: rawData.creature?.picture,\r\n      description: rawData.creature?.description,\r\n      flySpeed: extractVariable(rawData.variables, 'flySpeed'),\r\n      swimSpeed: extractVariable(rawData.variables, 'swimSpeed'),\r\n      climbSpeed: extractVariable(rawData.variables, 'climbSpeed'),\r\n      damageImmunities: extractVariable(rawData.variables, 'damageImmunities'),\r\n      damageResistances: extractVariable(rawData.variables, 'damageResistances'),\r\n      damageVulnerabilities: extractVariable(rawData.variables, 'damageVulnerabilities'),\r\n      conditionImmunities: extractVariable(rawData.variables, 'conditionImmunities'),\r\n      languages: extractVariable(rawData.variables, 'languages'),\r\n      size: extractVariable(rawData.variables, 'size') || 'medium',\r\n      currency: {\r\n        pp: extractVariable(rawData.variables, 'pp') || 0,\r\n        gp: extractVariable(rawData.variables, 'gp') || 0,\r\n        ep: extractVariable(rawData.variables, 'ep') || 0,\r\n        sp: extractVariable(rawData.variables, 'sp') || 0,\r\n        cp: extractVariable(rawData.variables, 'cp') || 0\r\n      },\r\n      experiencePoints: extractVariable(rawData.variables, 'experiencePoints') || 0\r\n    }\r\n  };\r\n\r\n  console.log('\u2705 Parsed for Foundry VTT:', foundryData.name);\r\n  return foundryData;\r\n}\r\n\r\n/**\r\n * Helper to extract variable value from DiceCloud variables\r\n */\r\nfunction extractVariable(variables, varName) {\r\n  if (!variables || !variables[varName]) return null;\r\n  const varData = variables[varName];\r\n  return varData.value !== undefined ? varData.value : varData;\r\n}\r\n"],
  "mappings": "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",
  "names": ["variables", "result", "raceName", "formula", "tags", "level"]
}
