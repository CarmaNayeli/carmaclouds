{
  "version": 3,
  "sources": ["../../../core/src/supabase/config.js", "../../src/background.js"],
  "sourcesContent": ["/**\r\n * Supabase Configuration\r\n * Single Supabase instance shared across all CarmaClouds projects\r\n */\r\n\r\n// Shared Supabase instance\r\nexport const SUPABASE_URL = 'https://luiesmfjdcmpywavvfqm.supabase.co';\r\nexport const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx1aWVzbWZqZGNtcHl3YXZ2ZnFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4ODYxNDksImV4cCI6MjA4NTQ2MjE0OX0.oqjHFf2HhCLcanh0HVryoQH7iSV7E9dHHZJdYehxZ0U';\r\n\r\n/**\r\n * Table names for different projects\r\n */\r\nexport const TABLES = {\r\n  // Shared tables\r\n  AUTH_TOKENS: 'auth_tokens',\r\n  PAIRINGS: 'clouds_pairings',\r\n\r\n  // Project-specific character tables\r\n  OWLCLOUD_CHARACTERS: 'clouds_characters',\r\n  ROLLCLOUD_CHARACTERS: 'rollcloud_characters',\r\n  FOUNDCLOUD_CHARACTERS: 'foundcloud_characters', // Future\r\n};\r\n\r\n/**\r\n * Project-specific configurations\r\n */\r\nexport const PROJECT_CONFIGS = {\r\n  owlcloud: {\r\n    characterTable: TABLES.OWLCLOUD_CHARACTERS,\r\n    pairingTable: TABLES.PAIRINGS,\r\n    cacheStorageKey: 'owlcloud_character_cache',\r\n  },\r\n  rollcloud: {\r\n    characterTable: TABLES.ROLLCLOUD_CHARACTERS,\r\n    pairingTable: TABLES.PAIRINGS,\r\n    cacheStorageKey: 'rollcloud_character_cache',\r\n  },\r\n  foundcloud: {\r\n    characterTable: TABLES.FOUNDCLOUD_CHARACTERS,\r\n    pairingTable: TABLES.PAIRINGS,\r\n    cacheStorageKey: 'foundcloud_character_cache',\r\n  },\r\n};\r\n\r\n/**\r\n * Get configuration for a specific project\r\n * @param {string} projectName - Project name (owlcloud, rollcloud, foundcloud)\r\n * @returns {Object} Project configuration\r\n */\r\nexport function getProjectConfig(projectName) {\r\n  const config = PROJECT_CONFIGS[projectName];\r\n  if (!config) {\r\n    throw new Error(`Unknown project: ${projectName}`);\r\n  }\r\n  return {\r\n    ...config,\r\n    supabaseUrl: SUPABASE_URL,\r\n    supabaseKey: SUPABASE_ANON_KEY,\r\n  };\r\n}\r\n", "/**\r\n * Background Script - Chrome & Firefox Support\r\n * Handles data storage, API authentication, and communication between Dice Cloud and Roll20\r\n */\r\n\r\n// Import Supabase config for service worker context\r\nimport { SUPABASE_URL, SUPABASE_ANON_KEY } from '@carmaclouds/core/supabase/config.js';\r\n\r\n// Service worker context doesn't have window, so define debug locally\r\nconst debug = {\r\n  log: console.log.bind(console),\r\n  warn: console.warn.bind(console),\r\n  error: console.error.bind(console),\r\n  info: console.info.bind(console),\r\n  group: console.group.bind(console),\r\n  groupEnd: console.groupEnd.bind(console),\r\n  table: console.table.bind(console),\r\n  time: console.time.bind(console),\r\n  timeEnd: console.timeEnd.bind(console),\r\n  isEnabled: () => true\r\n};\r\n\r\ndebug.log('FoundCloud: Background script starting...');\r\n\r\n// Add startup storage check to debug auth persistence\r\n(async () => {\r\n  try {\r\n    const startupStorage = await browserAPI.storage.local.get(['diceCloudToken', 'diceCloudUserId', 'tokenExpires', 'username', 'explicitlyLoggedOut']);\r\n    debug.log('\uD83D\uDE80 Background script startup storage state:', {\r\n      hasToken: !!startupStorage.diceCloudToken,\r\n      tokenLength: startupStorage.diceCloudToken ? startupStorage.diceCloudToken.length : 0,\r\n      tokenStart: startupStorage.diceCloudToken ? startupStorage.diceCloudToken.substring(0, 20) + '...' : 'none',\r\n      username: startupStorage.username,\r\n      diceCloudUserId: startupStorage.diceCloudUserId,\r\n      tokenExpires: startupStorage.tokenExpires,\r\n      explicitlyLoggedOut: startupStorage.explicitlyLoggedOut,\r\n      allKeys: Object.keys(startupStorage)\r\n    });\r\n\r\n    // If we have a token but no explicitlyLoggedOut flag, ensure we're in a good state\r\n    if (startupStorage.diceCloudToken && !startupStorage.explicitlyLoggedOut) {\r\n      debug.log('\u2705 Service worker restarted with valid auth state');\r\n      \r\n      // Validate the token expiry on startup\r\n      if (startupStorage.tokenExpires) {\r\n        const expiryDate = new Date(startupStorage.tokenExpires);\r\n        const now = new Date();\r\n        \r\n        if (!isNaN(expiryDate.getTime()) && now < expiryDate) {\r\n          debug.log('\u2705 Token is still valid on startup');\r\n        } else if (isNaN(expiryDate.getTime())) {\r\n          debug.warn('\u26A0\uFE0F Invalid expiry date on startup, clearing it');\r\n          await browserAPI.storage.local.remove('tokenExpires');\r\n        } else {\r\n          debug.warn('\u23F0 Token expired on startup, logging out');\r\n          await logout();\r\n        }\r\n      }\r\n    } else if (startupStorage.explicitlyLoggedOut) {\r\n      debug.log('\u23ED\uFE0F Service worker restarted after explicit logout');\r\n    } else {\r\n      debug.log('\uD83D\uDD0D No auth state found on startup');\r\n    }\r\n  } catch (error) {\r\n    debug.error('Failed to check startup storage:', error);\r\n  }\r\n})();\r\n\r\n// Detect browser and use appropriate API\r\n// For Firefox, use the native Promise-based 'browser' API\r\n// For Chrome, use native 'chrome' API directly (no polyfill needed in service worker)\r\nconst browserAPI = (typeof browser !== 'undefined' && browser.runtime) ? browser : chrome;\r\n\r\n// Detect which browser we're running on\r\nconst isFirefox = typeof browser !== 'undefined';\r\ndebug.log('FoundCloud: Background script initialized on', isFirefox ? 'Firefox' : 'Chrome');\r\n\r\n// Add service worker lifecycle listeners for Chrome\r\nif (!isFirefox && chrome.runtime && chrome.runtime.onSuspend) {\r\n  chrome.runtime.onSuspend.addListener(() => {\r\n    debug.log('\uD83D\uDD0C Service worker suspending - saving state...');\r\n    // Any cleanup before suspension goes here\r\n  });\r\n}\r\n\r\nif (!isFirefox && chrome.runtime && chrome.runtime.onSuspendCanceled) {\r\n  chrome.runtime.onSuspendCanceled.addListener(() => {\r\n    debug.log('\u267B\uFE0F Service worker suspension canceled');\r\n  });\r\n}\r\n\r\nif (!isFirefox && chrome.runtime && chrome.runtime.onStartup) {\r\n  chrome.runtime.onStartup.addListener(() => {\r\n    debug.log('\uD83D\uDE80 Chrome startup event received');\r\n  });\r\n}\r\n\r\nlet keepAliveInterval = null;\r\n\r\n/**\r\n * Keeps the service worker alive during critical operations\r\n * Chrome service workers can be terminated after ~5 minutes of inactivity\r\n */\r\nfunction keepServiceWorkerAlive(durationMs = 30000) {\r\n  if (keepAliveInterval) {\r\n    clearInterval(keepAliveInterval);\r\n  }\r\n  \r\n  debug.log('\uD83D\uDC93 Keeping service worker alive for', durationMs, 'ms');\r\n  \r\n  // Use chrome.alarms API if available, otherwise fallback to setInterval\r\n  if (chrome.alarms) {\r\n    chrome.alarms.create('keepAlive', { delayInMinutes: durationMs / 60000 });\r\n    chrome.alarms.onAlarm.addListener((alarm) => {\r\n      if (alarm.name === 'keepAlive') {\r\n        debug.log('\uD83D\uDC93 Keep-alive alarm triggered');\r\n      }\r\n    });\r\n  } else {\r\n    // Fallback: ping ourselves every 25 seconds\r\n    keepAliveInterval = setInterval(() => {\r\n      debug.log('\uD83D\uDC93 Service worker keep-alive ping');\r\n    }, 25000);\r\n    \r\n    setTimeout(() => {\r\n      if (keepAliveInterval) {\r\n        clearInterval(keepAliveInterval);\r\n        keepAliveInterval = null;\r\n        debug.log('\uD83D\uDC93 Keep-alive interval cleared');\r\n      }\r\n    }, durationMs);\r\n  }\r\n}\r\n\r\n/**\r\n * Stops the keep-alive mechanism\r\n */\r\nfunction stopKeepAlive() {\r\n  if (keepAliveInterval) {\r\n    clearInterval(keepAliveInterval);\r\n    keepAliveInterval = null;\r\n  }\r\n  if (chrome.alarms) {\r\n    chrome.alarms.clear('keepAlive');\r\n  }\r\n  debug.log('\uD83D\uDC94 Keep-alive stopped');\r\n}\r\nif (isFirefox) {\r\n  debug.log('\uD83E\uDD8A Firefox detected - checking extension context...');\r\n  \r\n  // Test if we can access runtime\r\n  try {\r\n    const manifest = browserAPI.runtime.getManifest();\r\n    debug.log('\u2705 Firefox runtime accessible, version:', manifest.version);\r\n  } catch (error) {\r\n    debug.error('\u274C Firefox runtime not accessible:', error);\r\n  }\r\n  \r\n  // Test storage\r\n  try {\r\n    browserAPI.storage.local.get(['test'], (result) => {\r\n      if (browserAPI.runtime.lastError) {\r\n        debug.error('\u274C Firefox storage error:', browserAPI.runtime.lastError);\r\n      } else {\r\n        debug.log('\u2705 Firefox storage working');\r\n      }\r\n    });\r\n  } catch (error) {\r\n    debug.error('\u274C Firefox storage test error:', error);\r\n  }\r\n}\r\n\r\nconst API_BASE = 'https://dicecloud.com/api';\r\n\r\n// Listen for messages from content scripts and popup\r\nbrowserAPI.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  debug.log('Background received message:', request);\r\n  debug.log('Message sender:', sender);\r\n\r\n  // If this is a content script message, let it handle itself\r\n  if (sender.tab && request.action === 'extractAuthToken') {\r\n    debug.log('\uD83D\uDCE4 Passing extractAuthToken to content script - not handling in background');\r\n    return false; // Don't handle here, let content script handle it\r\n  }\r\n\r\n  // Handle async operations and call sendResponse when done\r\n  // This pattern keeps the message port open until sendResponse is called\r\n  (async () => {\r\n    try {\r\n      let response;\r\n\r\n      switch (request.action) {\r\n        case 'storeCharacterData':\r\n          await storeCharacterData(request.data, request.slotId);\r\n          // Auto-sync to Supabase if Discord is connected (for Discord bot commands)\r\n          // This ensures spells/actions are always available to Discord commands\r\n          try {\r\n            if (typeof SupabaseTokenManager !== 'undefined') {\r\n              const webhookSettings = await browserAPI.storage.local.get(['discordWebhookEnabled', 'discordUserId']);\r\n              const shouldAutoSync = request.syncToCloud || webhookSettings.discordWebhookEnabled || webhookSettings.discordUserId;\r\n              if (shouldAutoSync) {\r\n                debug.log('\u2601\uFE0F Auto-syncing character to cloud (Discord connected)');\r\n                await storeCharacterToCloud(request.data, request.pairingCode);\r\n              }\r\n            }\r\n          } catch (syncError) {\r\n            debug.warn('\u26A0\uFE0F Auto-sync to cloud failed (non-fatal):', syncError.message);\r\n          }\r\n          response = { success: true };\r\n          break;\r\n\r\n        case 'syncCharacterToCloud': {\r\n          // Explicitly sync character to Supabase\r\n          const syncResult = await storeCharacterToCloud(request.characterData, request.pairingCode);\r\n          response = syncResult;\r\n          break;\r\n        }\r\n\r\n        case 'syncCharacterColor': {\r\n          // Sync character color to Supabase\r\n          const syncResult = await syncCharacterColorToSupabase(request.characterId, request.color);\r\n          response = syncResult;\r\n          break;\r\n        }\r\n\r\n        case 'checkDiscordCharacterIntegration': {\r\n          // Check if current character is active in Discord bot\r\n          const checkResult = await checkDiscordCharacterIntegration(request.characterName, request.characterId);\r\n          response = checkResult;\r\n          break;\r\n        }\r\n\r\n        case 'fetchDiceCloudAPI': {\r\n          // Fetch from DiceCloud API (used by Roll20 content script)\r\n          const fetchResult = await fetchFromDiceCloudAPI(request.url, request.token);\r\n          response = fetchResult;\r\n          break;\r\n        }\r\n\r\n        case 'getCharacterData': {\r\n          const data = await getCharacterData(request.characterId);\r\n          response = { success: true, data };\r\n          break;\r\n        }\r\n\r\n        case 'getCharacterDataFromDatabase': {\r\n          // Handle database character loading\r\n          const data = await getCharacterDataFromDatabase(request.characterId);\r\n          response = { success: true, data };\r\n          break;\r\n        }\r\n\r\n        case 'getAllCharacterProfiles': {\r\n          const profiles = await getAllCharacterProfiles();\r\n          response = { success: true, profiles };\r\n          break;\r\n        }\r\n\r\n        case 'setActiveCharacter':\r\n          await setActiveCharacter(request.characterId);\r\n          response = { success: true };\r\n          break;\r\n\r\n        case 'clearCharacterData':\r\n          await clearCharacterData(request.characterId);\r\n          response = { success: true };\r\n          break;\r\n\r\n        case 'loginToDiceCloud': {\r\n          const authData = await loginToDiceCloud(request.username, request.password);\r\n          response = { success: true, authData };\r\n          break;\r\n        }\r\n\r\n        case 'setApiToken': {\r\n          await setApiToken(request.token, request.userId, request.tokenExpires, request.username);\r\n          response = { success: true };\r\n          break;\r\n        }\r\n\r\n        case 'getApiToken': {\r\n          const token = await getApiToken();\r\n          response = { success: true, token };\r\n          break;\r\n        }\r\n\r\n        case 'getManifest': {\r\n          const manifest = browserAPI.runtime.getManifest();\r\n          response = { success: true, manifest };\r\n          break;\r\n        }\r\n\r\n        case 'logout':\r\n          await logout();\r\n          response = { success: true };\r\n          break;\r\n\r\n        case 'rollResult':\r\n          // Forward roll result to Roll20 content script for popup forwarding\r\n          debug.log('\uD83E\uDDEC Forwarding roll result to Roll20 for popup:', request);\r\n          \r\n          // Send to Roll20 content script to forward to popup\r\n          const roll20Tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n          if (roll20Tabs.length > 0) {\r\n            await browserAPI.tabs.sendMessage(roll20Tabs[0].id, {\r\n              action: 'forwardToPopup',\r\n              rollResult: request.rollResult,\r\n              baseRoll: request.baseRoll,\r\n              characterName: request.characterName,\r\n              characterId: request.characterId\r\n            });\r\n            response = { success: true };\r\n          } else {\r\n            response = { success: false, error: 'No Roll20 tabs found' };\r\n          }\r\n          break;\r\n\r\n        case 'relayRollToRoll20': {\r\n          // Relay roll from popup-sheet to Roll20 content script\r\n          debug.log('\uD83C\uDFB2 Relaying roll to Roll20:', request.roll);\r\n\r\n          const r20Tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n          if (r20Tabs.length > 0) {\r\n            for (const tab of r20Tabs) {\r\n              try {\r\n                await browserAPI.tabs.sendMessage(tab.id, {\r\n                  action: 'rollFromPopout',\r\n                  roll: request.roll,\r\n                  name: request.roll?.name,\r\n                  formula: request.roll?.formula,\r\n                  characterName: request.roll?.characterName\r\n                });\r\n                debug.log('\u2705 Roll relayed to Roll20 tab:', tab.id);\r\n              } catch (tabError) {\r\n                debug.warn('\u26A0\uFE0F Could not send to tab', tab.id, tabError.message);\r\n              }\r\n            }\r\n            response = { success: true };\r\n          } else {\r\n            debug.warn('\u26A0\uFE0F No Roll20 tabs found to relay roll');\r\n            response = { success: false, error: 'No Roll20 tabs found' };\r\n          }\r\n          break;\r\n        }\r\n\r\n        // Handle extractAuthToken with tabId and forward to content script\r\n        case 'extractAuthToken': {\r\n          if (request.tabId) {\r\n            debug.log('\uD83D\uDCE4 Forwarding extractAuthToken to tab:', request.tabId);\r\n            try {\r\n              const contentResponse = await browserAPI.tabs.sendMessage(request.tabId, {\r\n                action: 'extractAuthToken'\r\n              });\r\n              debug.log('\uD83D\uDCE5 Received response from content script:', contentResponse);\r\n              response = { success: true, data: contentResponse };\r\n            } catch (error) {\r\n              debug.error('\u274C Error forwarding to content script:', error);\r\n              response = { success: false, error: error.message };\r\n            }\r\n          } else {\r\n            response = { success: false, error: 'No tabId provided' };\r\n          }\r\n          break;\r\n        }\r\n\r\n        // ============== Discord Pairing Message Handlers ==============\r\n\r\n        case 'checkLoginStatus': {\r\n          const loginStatus = await checkLoginStatus();\r\n          response = { success: true, ...loginStatus };\r\n          break;\r\n        }\r\n\r\n        case 'toggleGMMode': {\r\n          // Forward GM Mode toggle to all Roll20 tabs\r\n          debug.log('\uD83D\uDC51 Received toggleGMMode request, forwarding to Roll20 tabs');\r\n          await sendGMModeToggleToRoll20Tabs(request.enabled);\r\n          response = { success: true };\r\n          break;\r\n        }\r\n\r\n        case 'createDiscordPairing': {\r\n          const pairingResult = await createDiscordPairing(request.code, request.username, request.diceCloudUserId);\r\n          response = pairingResult;\r\n          break;\r\n        }\r\n\r\n        case 'checkDiscordPairing': {\r\n          const checkResult = await checkDiscordPairing(request.code);\r\n          response = checkResult;\r\n          break;\r\n        }\r\n\r\n        case 'setDiscordWebhook': {\r\n          // Use request.enabled if provided, otherwise default to true when URL is provided\r\n          const enabled = request.enabled !== undefined ? request.enabled : !!request.webhookUrl;\r\n          debug.log('\uD83D\uDCDD setDiscordWebhook called:', {\r\n            webhookUrl: request.webhookUrl ? `${request.webhookUrl.substring(0, 50)}...` : '(empty)',\r\n            enabled,\r\n            serverName: request.serverName,\r\n            pairingId: request.pairingId\r\n          });\r\n          await setDiscordWebhookSettings(request.webhookUrl, enabled, request.serverName);\r\n          // Also set the pairing ID for command polling if provided\r\n          if (request.pairingId) {\r\n            currentPairingId = request.pairingId;\r\n            await browserAPI.storage.local.set({\r\n              currentPairingId: request.pairingId,\r\n              discordPairingId: request.pairingId\r\n            });\r\n            // Subscribe to command realtime\r\n            subscribeToCommandRealtime(request.pairingId);\r\n          }\r\n          // Link Discord user info to auth_tokens if provided\r\n          if (request.discordUserId && request.discordUserId !== 'null') {\r\n            await linkDiscordUserToAuthTokens(\r\n              request.discordUserId,\r\n              request.discordUsername,\r\n              request.discordGlobalName\r\n            );\r\n          }\r\n          response = { success: true };\r\n          break;\r\n        }\r\n\r\n        case 'getDiscordWebhook': {\r\n          const settings = await getDiscordWebhookSettings();\r\n\r\n          // If connected, ensure discord_user_id is linked to auth_tokens\r\n          if (settings.enabled && settings.webhookUrl) {\r\n            const stored = await browserAPI.storage.local.get(['discordPairingId']);\r\n            if (stored.discordPairingId && isSupabaseConfigured()) {\r\n              try {\r\n                const pairingResponse = await fetch(\r\n                  `${SUPABASE_URL}/rest/v1/rollcloud_pairings?id=eq.${stored.discordPairingId}&select=discord_user_id,discord_username,discord_global_name`,\r\n                  {\r\n                    headers: {\r\n                      'apikey': SUPABASE_ANON_KEY,\r\n                      'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n                    }\r\n                  }\r\n                );\r\n                if (pairingResponse.ok) {\r\n                  const pairings = await pairingResponse.json();\r\n                  if (pairings.length > 0 && pairings[0].discord_user_id) {\r\n                    // Ensure auth_tokens has all Discord info\r\n                    await linkDiscordUserToAuthTokens(\r\n                      pairings[0].discord_user_id,\r\n                      pairings[0].discord_username,\r\n                      pairings[0].discord_global_name\r\n                    );\r\n                  }\r\n                }\r\n              } catch (e) {\r\n                debug.warn('Could not sync discord_user_id on getDiscordWebhook:', e);\r\n              }\r\n            }\r\n          }\r\n\r\n          response = { success: true, ...settings };\r\n          break;\r\n        }\r\n\r\n        case 'testDiscordWebhook': {\r\n          const testResult = await testDiscordWebhook(request.webhookUrl);\r\n          response = testResult;\r\n          break;\r\n        }\r\n\r\n        case 'requestPairingCodeFromInstaller': {\r\n          // Request pairing code from native messaging host\r\n          if (installerPort) {\r\n            installerPort.postMessage({ type: 'getPairingCode' });\r\n            response = { success: true, message: 'Pairing code requested from installer' };\r\n          } else {\r\n            // Try to connect first\r\n            const port = await connectToInstaller();\r\n            if (port) {\r\n              port.postMessage({ type: 'getPairingCode' });\r\n              response = { success: true, message: 'Connected and requested pairing code' };\r\n            } else {\r\n              response = { success: false, error: 'Could not connect to installer' };\r\n            }\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'getRealtimeStatus': {\r\n          // Return current Realtime connection status for debugging\r\n          const realtimeConnected = commandRealtimeSocket && commandRealtimeSocket.readyState === WebSocket.OPEN;\r\n          const settings = await browserAPI.storage.local.get(['discordPairingId', 'discordWebhookEnabled']);\r\n          response = {\r\n            success: true,\r\n            realtimeConnected,\r\n            socketState: commandRealtimeSocket ? commandRealtimeSocket.readyState : null,\r\n            currentPairingId,\r\n            storedPairingId: settings.discordPairingId,\r\n            webhookEnabled: settings.discordWebhookEnabled,\r\n            supabaseConfigured: isSupabaseConfigured()\r\n          };\r\n          debug.log('Realtime status:', response);\r\n          break;\r\n        }\r\n\r\n        default:\r\n          debug.warn('Unknown action:', request.action);\r\n          response = { success: false, error: 'Unknown action: ' + request.action };\r\n          break;\r\n      }\r\n\r\n      debug.log('Sending response:', response);\r\n      sendResponse(response);\r\n    } catch (error) {\r\n      debug.error('Error handling message:', error);\r\n      sendResponse({ success: false, error: error.message });\r\n    }\r\n  })();\r\n\r\n  // Return true to indicate we'll respond asynchronously\r\n  return true;\r\n});\r\n\r\n/**\r\n * Logs in to DiceCloud API with username/password\r\n * Per DiceCloud API docs: POST https://dicecloud.com/api/login\r\n * Accepts either username or email with password\r\n */\r\nasync function loginToDiceCloud(username, password) {\r\n  try {\r\n    // Keep service worker alive during login process\r\n    keepServiceWorkerAlive(60000); // Keep alive for 1 minute during login\r\n    \r\n    // Try to determine if input is email or username\r\n    const isEmail = username.includes('@');\r\n\r\n    const response = await fetch(`${API_BASE}/login`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify(isEmail ? {\r\n        email: username,\r\n        password: password\r\n      } : {\r\n        username: username,\r\n        password: password\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Login failed: ${response.status} - ${errorText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    // Store authentication data including token expiry\r\n    await browserAPI.storage.local.set({\r\n      diceCloudToken: data.token,\r\n      diceCloudUserId: data.id,\r\n      tokenExpires: data.tokenExpires,\r\n      username: username\r\n    });\r\n\r\n    // Clear the explicitly logged out flag since user is now logging in\r\n    await browserAPI.storage.local.remove(['explicitlyLoggedOut']);\r\n\r\n    debug.log('Successfully logged in to DiceCloud');\r\n    debug.log('Token expires:', data.tokenExpires);\r\n    \r\n    // Keep alive a bit longer to ensure token is properly stored\r\n    setTimeout(() => stopKeepAlive(), 5000);\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    stopKeepAlive();\r\n    debug.error('Failed to login to DiceCloud:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Stores the API token (extracted from DiceCloud session or manually entered)\r\n */\r\nasync function setApiToken(token, userId = null, tokenExpires = null, username = null) {\r\n  try {\r\n    // Keep service worker alive during token storage\r\n    keepServiceWorkerAlive(30000); // Keep alive for 30 seconds\r\n    \r\n    debug.log('\uD83D\uDD10 setApiToken called:', {\r\n      tokenLength: token ? token.length : 0,\r\n      tokenStart: token ? token.substring(0, 20) + '...' : 'none',\r\n      userId,\r\n      tokenExpires,\r\n      username\r\n    });\r\n\r\n    // Validate token format (basic check)\r\n    if (!token || token.length < 10) {\r\n      throw new Error('Invalid API token format');\r\n    }\r\n\r\n    // Store the API token with optional metadata\r\n    const storageData = {\r\n      diceCloudToken: token,\r\n      username: username || 'DiceCloud User'\r\n    };\r\n\r\n    if (userId) {\r\n      storageData.diceCloudUserId = userId;\r\n    }\r\n\r\n    if (tokenExpires) {\r\n      storageData.tokenExpires = tokenExpires;\r\n    }\r\n\r\n    await browserAPI.storage.local.set(storageData);\r\n\r\n    // Clear the explicitly logged out flag since user is now logging in\r\n    await browserAPI.storage.local.remove(['explicitlyLoggedOut']);\r\n    \r\n    // Also clear any invalid expiry dates that might cause issues\r\n    const existing = await browserAPI.storage.local.get(['tokenExpires']);\r\n    if (existing.tokenExpires) {\r\n      const testDate = new Date(existing.tokenExpires);\r\n      if (isNaN(testDate.getTime())) {\r\n        debug.warn('\uD83E\uDDF9 Clearing invalid tokenExpires format:', existing.tokenExpires);\r\n        await browserAPI.storage.local.remove('tokenExpires');\r\n      }\r\n    }\r\n\r\n    // Verify the token was stored correctly\r\n    const verification = await browserAPI.storage.local.get(['diceCloudToken', 'diceCloudUserId', 'tokenExpires', 'username']);\r\n    debug.log('\u2705 setApiToken verification:', {\r\n      storedToken: verification.diceCloudToken ? verification.diceCloudToken.substring(0, 20) + '...' : 'none',\r\n      storedUserId: verification.diceCloudUserId,\r\n      storedUsername: verification.username,\r\n      storedExpires: verification.tokenExpires\r\n    });\r\n\r\n    debug.log('Successfully stored API token');\r\n    \r\n    // Keep alive a bit longer to ensure token is properly stored\r\n    setTimeout(() => stopKeepAlive(), 3000);\r\n    \r\n    return { success: true };\r\n  } catch (error) {\r\n    stopKeepAlive();\r\n    debug.error('Failed to store API token:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the stored API token\r\n * Checks expiry for tokens obtained via username/password login\r\n */\r\nasync function getApiToken() {\r\n  try {\r\n    const result = await browserAPI.storage.local.get(['diceCloudToken', 'tokenExpires']);\r\n    \r\n    debug.log('\uD83D\uDD0D getApiToken called, storage result:', {\r\n      hasToken: !!result.diceCloudToken,\r\n      tokenLength: result.diceCloudToken ? result.diceCloudToken.length : 0,\r\n      tokenStart: result.diceCloudToken ? result.diceCloudToken.substring(0, 20) + '...' : 'none',\r\n      tokenExpires: result.tokenExpires,\r\n      allKeys: Object.keys(result)\r\n    });\r\n\r\n    if (!result.diceCloudToken) {\r\n      debug.warn('\u274C No diceCloudToken found in storage');\r\n      return null;\r\n    }\r\n\r\n    // Check if token is expired (only if tokenExpires exists - API tokens don't expire)\r\n    if (result.tokenExpires) {\r\n      let expiryDate;\r\n      \r\n      // Handle different date formats that DiceCloud might send\r\n      if (typeof result.tokenExpires === 'number') {\r\n        // Unix timestamp (milliseconds)\r\n        expiryDate = new Date(result.tokenExpires);\r\n      } else if (typeof result.tokenExpires === 'string') {\r\n        // ISO string or other format\r\n        expiryDate = new Date(result.tokenExpires);\r\n        // Check if date parsing failed\r\n        if (isNaN(expiryDate.getTime())) {\r\n          debug.warn('\u26A0\uFE0F Invalid tokenExpires date format:', result.tokenExpires);\r\n          // Don't logout, just skip expiry check\r\n          expiryDate = null;\r\n        }\r\n      }\r\n      \r\n      const now = new Date();\r\n      debug.log('\uD83D\uDD0D Token expiry check:', {\r\n        tokenExpires: result.tokenExpires,\r\n        expiryDate: expiryDate ? expiryDate.toISOString() : 'invalid',\r\n        now: now.toISOString(),\r\n        isExpired: expiryDate ? now >= expiryDate : 'unknown'\r\n      });\r\n      \r\n      if (expiryDate && now >= expiryDate) {\r\n        debug.warn('\u23F0 API token has expired, logging out');\r\n        await logout();\r\n        return null;\r\n      }\r\n    }\r\n\r\n    debug.log('\u2705 getApiToken returning valid token');\r\n    return result.diceCloudToken;\r\n  } catch (error) {\r\n    debug.error('Failed to retrieve API token:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the user is logged in\r\n * Also validates token expiry for username/password logins\r\n */\r\nasync function checkLoginStatus() {\r\n  try {\r\n    const result = await browserAPI.storage.local.get(['diceCloudToken', 'username', 'tokenExpires', 'diceCloudUserId']);\r\n    \r\n    debug.log('\uD83D\uDD0D checkLoginStatus called, storage result:', {\r\n      hasToken: !!result.diceCloudToken,\r\n      tokenLength: result.diceCloudToken ? result.diceCloudToken.length : 0,\r\n      tokenStart: result.diceCloudToken ? result.diceCloudToken.substring(0, 20) + '...' : 'none',\r\n      username: result.username,\r\n      diceCloudUserId: result.diceCloudUserId,\r\n      tokenExpires: result.tokenExpires,\r\n      allKeys: Object.keys(result)\r\n    });\r\n\r\n    if (!result.diceCloudToken) {\r\n      debug.warn('\u274C checkLoginStatus: No diceCloudToken found');\r\n      return { loggedIn: false };\r\n    }\r\n\r\n    // Check if token is expired (only if tokenExpires exists - API tokens don't expire)\r\n    if (result.tokenExpires) {\r\n      let expiryDate;\r\n      \r\n      // Handle different date formats that DiceCloud might send\r\n      if (typeof result.tokenExpires === 'number') {\r\n        // Unix timestamp (milliseconds)\r\n        expiryDate = new Date(result.tokenExpires);\r\n      } else if (typeof result.tokenExpires === 'string') {\r\n        // ISO string or other format\r\n        expiryDate = new Date(result.tokenExpires);\r\n        // Check if date parsing failed\r\n        if (isNaN(expiryDate.getTime())) {\r\n          debug.warn('\u26A0\uFE0F Invalid tokenExpires date format in checkLoginStatus:', result.tokenExpires);\r\n          // Don't logout, just skip expiry check\r\n          expiryDate = null;\r\n        }\r\n      }\r\n      \r\n      const now = new Date();\r\n      debug.log('\uD83D\uDD0D Login status expiry check:', {\r\n        tokenExpires: result.tokenExpires,\r\n        expiryDate: expiryDate ? expiryDate.toISOString() : 'invalid',\r\n        now: now.toISOString(),\r\n        isExpired: expiryDate ? now >= expiryDate : 'unknown'\r\n      });\r\n      \r\n      if (expiryDate && now >= expiryDate) {\r\n        debug.warn('\u23F0 Session expired - please login again');\r\n        await logout();\r\n        return { loggedIn: false };\r\n      }\r\n    }\r\n\r\n    debug.log('\u2705 checkLoginStatus: User is logged in');\r\n    return {\r\n      loggedIn: true,\r\n      username: result.username || 'DiceCloud User',\r\n      userId: result.diceCloudUserId || null\r\n    };\r\n  } catch (error) {\r\n    debug.error('Failed to check login status:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Logs out (clears authentication data)\r\n */\r\nasync function logout() {\r\n  try {\r\n    debug.warn('\uD83D\uDEAA logout() called - getting current storage state...');\r\n    \r\n    // Get current state before clearing\r\n    const currentState = await browserAPI.storage.local.get(['diceCloudToken', 'diceCloudUserId', 'tokenExpires', 'username', 'explicitlyLoggedOut']);\r\n    debug.log('\uD83D\uDD0D Current storage before logout:', {\r\n      hasToken: !!currentState.diceCloudToken,\r\n      tokenLength: currentState.diceCloudToken ? currentState.diceCloudToken.length : 0,\r\n      username: currentState.username,\r\n      diceCloudUserId: currentState.diceCloudUserId,\r\n      tokenExpires: currentState.tokenExpires,\r\n      explicitlyLoggedOut: currentState.explicitlyLoggedOut\r\n    });\r\n\r\n    // Set flag first to prevent autoRefreshToken from re-saving the token\r\n    await browserAPI.storage.local.set({ explicitlyLoggedOut: true });\r\n    await browserAPI.storage.local.remove(['diceCloudToken', 'diceCloudUserId', 'tokenExpires', 'username']);\r\n    \r\n    debug.warn('\uD83D\uDEAA logout() completed - storage cleared');\r\n  } catch (error) {\r\n    debug.error('Failed to logout:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Stores character data in browserAPI.storage (supports multiple profiles)\r\n * @param {Object} characterData - Character data to store\r\n * @param {string} slotId - Optional slot ID (e.g., 'slot-1'). If not provided, uses characterId from data.\r\n */\r\nasync function storeCharacterData(characterData, slotId) {\r\n  try {\r\n    // Normalize field names: database uses character_name, DiceCloud uses name\r\n    // Ensure 'name' field exists for consistent display\r\n    if (characterData.character_name && !characterData.name) {\r\n      characterData.name = characterData.character_name;\r\n    }\r\n\r\n    // Use slotId if provided, otherwise fall back to character ID from the data\r\n    const storageId = slotId || characterData.id || characterData._id || 'default';\r\n\r\n    // Get existing profiles\r\n    const result = await browserAPI.storage.local.get(['characterProfiles', 'activeCharacterId']);\r\n    const characterProfiles = result.characterProfiles || {};\r\n\r\n    // Store this character's data EXACTLY as received\r\n    characterProfiles[storageId] = characterData;\r\n\r\n    // Only update activeCharacterId if slotId was explicitly provided\r\n    // This prevents the \"default\" storage from overriding a specific slot selection\r\n    const updates = {\r\n      characterProfiles: characterProfiles,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    // Only set activeCharacterId if there's no active character currently\r\n    // This prevents character data updates from overwriting user's character selection\r\n    if (!result.activeCharacterId) {\r\n      updates.activeCharacterId = storageId;\r\n      debug.log(`Setting active character to: ${storageId}`);\r\n    } else {\r\n      debug.log(`Keeping existing active character: ${result.activeCharacterId}`);\r\n    }\r\n\r\n    await browserAPI.storage.local.set(updates);\r\n\r\n    debug.log(`Character data stored successfully for ID: ${storageId}`, characterData);\r\n  } catch (error) {\r\n    debug.error('Failed to store character data:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieves character data from browserAPI.storage\r\n * If characterId is provided, returns that specific character\r\n * Otherwise returns the active character\r\n */\r\nasync function getCharacterData(characterId = null) {\r\n  try {\r\n    const result = await browserAPI.storage.local.get(['characterProfiles', 'activeCharacterId', 'characterData']);\r\n\r\n    // Migration: if old single characterData exists, migrate it\r\n    if (result.characterData && !result.characterProfiles) {\r\n      debug.log('Migrating old single character data to profiles...');\r\n      const charId = result.characterData.characterId || result.characterData._id || 'default';\r\n      const characterProfiles = {};\r\n      characterProfiles[charId] = result.characterData;\r\n\r\n      await browserAPI.storage.local.set({\r\n        characterProfiles: characterProfiles,\r\n        activeCharacterId: charId\r\n      });\r\n\r\n      // Remove old storage\r\n      await browserAPI.storage.local.remove('characterData');\r\n\r\n      return result.characterData;\r\n    }\r\n\r\n    // Get character profiles\r\n    const characterProfiles = result.characterProfiles || {};\r\n\r\n    // If specific character ID requested, return it\r\n    if (characterId) {\r\n      return characterProfiles[characterId] || null;\r\n    }\r\n\r\n    // Otherwise return active character\r\n    const activeCharacterId = result.activeCharacterId;\r\n    if (activeCharacterId && characterProfiles[activeCharacterId]) {\r\n      debug.log('Retrieved active character data:', characterProfiles[activeCharacterId]);\r\n      return characterProfiles[activeCharacterId];\r\n    }\r\n\r\n    // Fallback: return first available character\r\n    const characterIds = Object.keys(characterProfiles);\r\n    if (characterIds.length > 0) {\r\n      debug.log('No active character, returning first available:', characterProfiles[characterIds[0]]);\r\n      return characterProfiles[characterIds[0]];\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    debug.error('Failed to retrieve character data:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all character profiles from both local storage and database\r\n */\r\nasync function getAllCharacterProfiles() {\r\n  try {\r\n    // Get local profiles first\r\n    const localResult = await browserAPI.storage.local.get(['characterProfiles']);\r\n    const localProfiles = localResult.characterProfiles || {};\r\n\r\n    // Normalize local profiles: ensure 'name' field exists (database uses character_name)\r\n    for (const id of Object.keys(localProfiles)) {\r\n      const profile = localProfiles[id];\r\n      if (profile.character_name && !profile.name) {\r\n        profile.name = profile.character_name;\r\n      }\r\n    }\r\n\r\n    // Try to get database characters if SupabaseTokenManager is available\r\n    let databaseCharacters = {};\r\n    try {\r\n      if (typeof SupabaseTokenManager !== 'undefined') {\r\n        const supabase = new SupabaseTokenManager();\r\n        \r\n        // Get current user's DiceCloud ID from auth tokens\r\n        const tokenResult = await supabase.retrieveToken();\r\n        if (tokenResult.success && tokenResult.userId) {\r\n          debug.log('\uD83C\uDF10 Fetching database characters for DiceCloud user:', tokenResult.userId);\r\n          \r\n          // Get all characters for this user from database\r\n          const response = await fetch(\r\n            `${supabase.supabaseUrl}/rest/v1/rollcloud_characters?user_id_dicecloud=eq.${tokenResult.userId}&select=*`,\r\n            {\r\n              headers: {\r\n                'apikey': supabase.supabaseKey,\r\n                'Authorization': `Bearer ${supabase.supabaseKey}`\r\n              }\r\n            }\r\n          );\r\n          \r\n          if (response.ok) {\r\n            const characters = await response.json();\r\n            debug.log(`\uD83D\uDCE6 Found ${characters.length} characters in database`);\r\n            \r\n            // Convert database characters to profile format\r\n            characters.forEach(character => {\r\n              const slotId = `db-${character.dicecloud_character_id}`;\r\n              databaseCharacters[slotId] = {\r\n                name: character.character_name,\r\n                id: character.dicecloud_character_id,\r\n                source: 'database',\r\n                lastUpdated: character.updated_at,\r\n                race: character.race,\r\n                class: character.class,\r\n                level: character.level,\r\n                // Store full character data for loading\r\n                _fullData: character\r\n              };\r\n            });\r\n          } else {\r\n            debug.warn('\u26A0\uFE0F Failed to fetch database characters:', response.status);\r\n          }\r\n        }\r\n      }\r\n    } catch (dbError) {\r\n      debug.warn('\u26A0\uFE0F Failed to load database characters:', dbError);\r\n      // Continue with local profiles only\r\n    }\r\n    \r\n    // Merge local and database profiles\r\n    const mergedProfiles = { ...localProfiles, ...databaseCharacters };\r\n    \r\n    debug.log('\uD83D\uDCCB Character profiles loaded:', {\r\n      local: Object.keys(localProfiles).length,\r\n      database: Object.keys(databaseCharacters).length,\r\n      total: Object.keys(mergedProfiles).length\r\n    });\r\n    \r\n    return mergedProfiles;\r\n  } catch (error) {\r\n    debug.error('Failed to retrieve character profiles:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get character data from database by character ID\r\n */\r\nasync function getCharacterDataFromDatabase(characterId) {\r\n  try {\r\n    if (typeof SupabaseTokenManager === 'undefined') {\r\n      throw new Error('SupabaseTokenManager not available');\r\n    }\r\n\r\n    const supabase = new SupabaseTokenManager();\r\n    // Order by updated_at desc to always get the latest version\r\n    const response = await fetch(\r\n      `${supabase.supabaseUrl}/rest/v1/rollcloud_characters?dicecloud_character_id=eq.${characterId}&select=*&order=updated_at.desc&limit=1`,\r\n      {\r\n        headers: {\r\n          'apikey': supabase.supabaseKey,\r\n          'Authorization': `Bearer ${supabase.supabaseKey}`\r\n        }\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch database character: ${response.status}`);\r\n    }\r\n\r\n    const characters = await response.json();\r\n    if (characters.length === 0) {\r\n      throw new Error('Character not found in database');\r\n    }\r\n\r\n    const dbCharacter = characters[0];\r\n\r\n    // If raw_dicecloud_data contains the full character object, use it directly\r\n    // This preserves all parsed data (spells, features, actions, etc.) exactly as synced\r\n    let rawData = dbCharacter.raw_dicecloud_data;\r\n\r\n    // Handle raw_dicecloud_data being a JSON string (Supabase may return JSONB as string in some cases)\r\n    if (rawData && typeof rawData === 'string') {\r\n      try {\r\n        rawData = JSON.parse(rawData);\r\n        debug.log('\uD83D\uDCE6 Parsed raw_dicecloud_data from JSON string');\r\n      } catch (parseError) {\r\n        debug.warn('\u26A0\uFE0F raw_dicecloud_data is a string but not valid JSON:', parseError.message);\r\n        rawData = null;\r\n      }\r\n    }\r\n\r\n    if (rawData && typeof rawData === 'object' && !Array.isArray(rawData)) {\r\n      const fullCharacter = rawData;\r\n      // Add database metadata\r\n      fullCharacter.source = 'database';\r\n      fullCharacter.lastUpdated = dbCharacter.updated_at;\r\n      // Ensure ID fields are set correctly (in case of older records)\r\n      if (!fullCharacter.id) {\r\n        fullCharacter.id = dbCharacter.dicecloud_character_id;\r\n      }\r\n      if (!fullCharacter.name) {\r\n        fullCharacter.name = dbCharacter.character_name;\r\n      }\r\n      debug.log('\u2705 Loaded full character from database raw_dicecloud_data:', fullCharacter.name,\r\n        'HP:', JSON.stringify(fullCharacter.hitPoints),\r\n        'AC:', fullCharacter.armorClass,\r\n        'Prof:', fullCharacter.proficiencyBonus);\r\n      return fullCharacter;\r\n    }\r\n\r\n    // Fallback: Return database record with minimal transformation\r\n    // This should rarely be used since raw_dicecloud_data should always be present\r\n    debug.warn('\u26A0\uFE0F No raw_dicecloud_data found (type:', typeof rawData, '), using database fields directly');\r\n    debug.warn('\u26A0\uFE0F DB record keys:', Object.keys(dbCharacter));\r\n    const characterData = {\r\n      // Use the exact database field names to maintain consistency\r\n      id: dbCharacter.dicecloud_character_id,\r\n      name: dbCharacter.character_name,\r\n      race: dbCharacter.race,\r\n      class: dbCharacter.class,\r\n      level: dbCharacter.level,\r\n      alignment: dbCharacter.alignment,\r\n      hitPoints: dbCharacter.hit_points,\r\n      hitDice: dbCharacter.hit_dice,\r\n      temporaryHP: dbCharacter.temporary_hp,\r\n      deathSaves: dbCharacter.death_saves,\r\n      inspiration: dbCharacter.inspiration,\r\n      armorClass: dbCharacter.armor_class,\r\n      speed: dbCharacter.speed,\r\n      initiative: dbCharacter.initiative,\r\n      proficiencyBonus: dbCharacter.proficiency_bonus,\r\n      attributes: dbCharacter.attributes,\r\n      attributeMods: dbCharacter.attribute_mods,\r\n      saves: dbCharacter.saves,\r\n      skills: dbCharacter.skills,\r\n      spellSlots: dbCharacter.spell_slots,\r\n      resources: dbCharacter.resources,\r\n      conditions: dbCharacter.conditions,\r\n      // Preserve the raw database record for debugging\r\n      rawDiceCloudData: dbCharacter,\r\n      source: 'database',\r\n      lastUpdated: dbCharacter.updated_at\r\n    };\r\n\r\n    debug.log('\u2705 Loaded character from database (individual fields):', characterData.name);\r\n    return characterData;\r\n  } catch (error) {\r\n    debug.error('\u274C Failed to get character data from database:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Sets the active character\r\n */\r\nasync function setActiveCharacter(characterId) {\r\n  try {\r\n    await browserAPI.storage.local.set({\r\n      activeCharacterId: characterId\r\n    });\r\n    debug.log(`Active character set to: ${characterId}`);\r\n\r\n    // Notify Roll20 tabs about the character change for experimental sync\r\n    try {\r\n      const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n      if (tabs.length > 0) {\r\n        // Get the character data to send the DiceCloud character ID\r\n        const result = await browserAPI.storage.local.get(['characterProfiles']);\r\n        const characterProfiles = result.characterProfiles || {};\r\n        const characterData = characterProfiles[characterId];\r\n\r\n        if (characterData && characterData.id) {\r\n          debug.log(`Broadcasting active character change to Roll20 tabs: ${characterData.id}`);\r\n          for (const tab of tabs) {\r\n            browserAPI.tabs.sendMessage(tab.id, {\r\n              action: 'activeCharacterChanged',\r\n              characterId: characterData.id,\r\n              slotId: characterId\r\n            }).catch(err => {\r\n              debug.warn(`Failed to notify tab ${tab.id} about character change:`, err);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      debug.warn('Failed to broadcast character change to Roll20 tabs:', error);\r\n    }\r\n  } catch (error) {\r\n    debug.error('Failed to set active character:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Clears stored character data (all profiles or specific profile)\r\n */\r\nasync function clearCharacterData(characterId = null) {\r\n  try {\r\n    if (characterId) {\r\n      // Clear specific character\r\n      const result = await browserAPI.storage.local.get(['characterProfiles', 'activeCharacterId']);\r\n      const characterProfiles = result.characterProfiles || {};\r\n      const activeCharacterId = result.activeCharacterId;\r\n\r\n      delete characterProfiles[characterId];\r\n\r\n      const updates = {\r\n        characterProfiles: characterProfiles\r\n      };\r\n\r\n      // If we just deleted the active character, switch to another one\r\n      if (activeCharacterId === characterId) {\r\n        const remainingIds = Object.keys(characterProfiles);\r\n        if (remainingIds.length > 0) {\r\n          // Set first available character as active\r\n          updates.activeCharacterId = remainingIds[0];\r\n          debug.log(`Active character was cleared, switching to ${remainingIds[0]}`);\r\n        } else {\r\n          // No characters left, clear active ID\r\n          updates.activeCharacterId = null;\r\n          debug.log('No characters remaining, clearing active character ID');\r\n        }\r\n      }\r\n\r\n      await browserAPI.storage.local.set(updates);\r\n\r\n      debug.log(`Character profile cleared for ID: ${characterId}`);\r\n    } else {\r\n      // Clear all characters\r\n      await browserAPI.storage.local.remove(['characterProfiles', 'activeCharacterId', 'timestamp']);\r\n      debug.log('All character data cleared successfully');\r\n    }\r\n  } catch (error) {\r\n    debug.error('Failed to clear character data:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Rolls in Dice Cloud and forwards to Roll20\r\n */\r\nasync function rollInDiceCloudAndForward(rollData) {\r\n  try {\r\n    // Find Dice Cloud tab\r\n    const diceCloudTabs = await browserAPI.tabs.query({ url: '*://dicecloud.com/*' });\r\n    \r\n    if (diceCloudTabs.length === 0) {\r\n      throw new Error('No Dice Cloud tab found. Please open Dice Cloud first.');\r\n    }\r\n\r\n    // Send roll request to Dice Cloud\r\n    const diceCloudTab = diceCloudTabs[0];\r\n    const response = await browserAPI.tabs.sendMessage(diceCloudTab.id, {\r\n      action: 'rollInDiceCloud',\r\n      roll: rollData\r\n    });\r\n\r\n    if (!response || !response.success) {\r\n      throw new Error('Failed to roll in Dice Cloud');\r\n    }\r\n\r\n    debug.log(' Roll initiated in Dice Cloud, will be forwarded automatically');\r\n    return response;\r\n  } catch (error) {\r\n    debug.error('Failed to roll in Dice Cloud:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Sends a roll to all open Roll20 tabs\r\n */\r\nasync function sendRollToAllRoll20Tabs(rollData) {\r\n  try {\r\n    // Query all tabs for Roll20\r\n    const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n    if (tabs.length === 0) {\r\n      debug.warn('\u26A0\uFE0F No Roll20 tabs found - roll not sent');\r\n      return { success: false, error: 'No Roll20 tabs open. Please open Roll20 in a browser tab.' };\r\n    }\r\n\r\n    // Send roll to each Roll20 tab with individual error handling\r\n    let successCount = 0;\r\n    let failCount = 0;\r\n    const errors = [];\r\n\r\n    for (const tab of tabs) {\r\n      try {\r\n        await browserAPI.tabs.sendMessage(tab.id, {\r\n          action: 'postRollToChat',\r\n          roll: rollData\r\n        });\r\n        successCount++;\r\n      } catch (err) {\r\n        failCount++;\r\n        debug.warn(`Failed to send roll to tab ${tab.id}:`, err.message);\r\n        errors.push(`Tab ${tab.id}: ${err.message}`);\r\n      }\r\n    }\r\n\r\n    if (successCount > 0) {\r\n      debug.log(`\u2705 Roll sent to ${successCount}/${tabs.length} Roll20 tab(s)`);\r\n      return { success: true, tabsSent: successCount, tabsFailed: failCount };\r\n    } else {\r\n      debug.error(`\u274C Failed to send roll to any Roll20 tabs. Errors: ${errors.join(', ')}`);\r\n      return { success: false, error: 'Failed to send roll to Roll20. Try refreshing the Roll20 page.' };\r\n    }\r\n  } catch (error) {\r\n    debug.error('Failed to send roll to Roll20 tabs:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Sends GM Mode toggle to all open Roll20 tabs\r\n */\r\nasync function sendGMModeToggleToRoll20Tabs(enabled) {\r\n  try {\r\n    // Query all tabs for Roll20\r\n    const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n    if (tabs.length === 0) {\r\n      debug.warn('No Roll20 tabs found');\r\n      return;\r\n    }\r\n\r\n    // Send GM Mode toggle to each Roll20 tab\r\n    const promises = tabs.map(tab => {\r\n      return browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'toggleGMMode',\r\n        enabled: enabled\r\n      }).catch(err => {\r\n        debug.warn(`Failed to send GM Mode toggle to tab ${tab.id}:`, err);\r\n      });\r\n    });\r\n\r\n    await Promise.all(promises);\r\n    debug.log(`GM Mode toggle sent to ${tabs.length} Roll20 tab(s)`);\r\n  } catch (error) {\r\n    debug.error('Failed to send GM Mode toggle to Roll20 tabs:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Sends chat message to all open Roll20 tabs\r\n */\r\nasync function sendChatMessageToAllRoll20Tabs(message) {\r\n  try {\r\n    // Query all tabs for Roll20\r\n    const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n    if (tabs.length === 0) {\r\n      debug.warn('No Roll20 tabs found');\r\n      return;\r\n    }\r\n\r\n    // Send chat message to each Roll20 tab\r\n    const promises = tabs.map(tab => {\r\n      return browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'postChatMessageFromPopup',\r\n        message: message\r\n      }).catch(err => {\r\n        debug.warn(`Failed to send chat message to tab ${tab.id}:`, err);\r\n      });\r\n    });\r\n\r\n    await Promise.all(promises);\r\n    debug.log(`Chat message sent to ${tabs.length} Roll20 tab(s)`);\r\n  } catch (error) {\r\n    debug.error('Failed to send chat message to Roll20 tabs:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle extension installation\r\n */\r\nbrowserAPI.runtime.onInstalled.addListener((details) => {\r\n  if (details.reason === 'install') {\r\n    debug.log('Extension installed');\r\n    \r\n    // Auto-open popup after installation\r\n    setTimeout(() => {\r\n      openExtensionPopup();\r\n    }, 1000); // Wait 1 second for extension to fully initialize\r\n    \r\n  } else if (details.reason === 'update') {\r\n    debug.log('Extension updated to version', browserAPI.runtime.getManifest().version);\r\n  }\r\n});\r\n\r\n/**\r\n * Open the extension popup\r\n */\r\nasync function openExtensionPopup() {\r\n  try {\r\n    debug.log('\uD83D\uDE80 Opening extension popup after installation...');\r\n    \r\n    // For Chrome, we can open the popup directly\r\n    if (!isFirefox) {\r\n      // Chrome doesn't have a direct API to open popup, but we can open the options page\r\n      // which serves a similar purpose for first-time setup\r\n      browserAPI.runtime.openOptionsPage();\r\n      debug.log('\u2705 Opened options page for Chrome');\r\n    } else {\r\n      // For Firefox, we can try to open the popup\r\n      try {\r\n        // Firefox doesn't have a direct popup opening API either\r\n        // So we'll open the options page as well\r\n        browserAPI.runtime.openOptionsPage();\r\n        debug.log('\u2705 Opened options page for Firefox');\r\n      } catch (error) {\r\n        debug.log('\u26A0\uFE0F Could not open options page:', error);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    debug.log('\u274C Error opening popup/options:', error);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Discord Webhook Integration\r\n// ============================================================================\r\n\r\n/**\r\n * Stores Discord webhook settings\r\n * @param {string} webhookUrl - The Discord webhook URL\r\n * @param {boolean} enabled - Whether notifications are enabled\r\n * @param {string} serverName - Optional Discord server name for display\r\n */\r\nasync function setDiscordWebhookSettings(webhookUrl, enabled = true, serverName = null) {\r\n  try {\r\n    const settings = {\r\n      discordWebhookUrl: webhookUrl || '',\r\n      discordWebhookEnabled: enabled\r\n    };\r\n    if (serverName) {\r\n      settings.discordServerName = serverName;\r\n    }\r\n    debug.log('\uD83D\uDCDD Saving Discord webhook settings:', {\r\n      webhookUrl: webhookUrl ? `${webhookUrl.substring(0, 50)}...` : '(empty)',\r\n      enabled,\r\n      serverName\r\n    });\r\n    await browserAPI.storage.local.set(settings);\r\n\r\n    // Verify storage was successful\r\n    const verification = await browserAPI.storage.local.get(['discordWebhookUrl', 'discordWebhookEnabled']);\r\n    debug.log('\u2705 Discord webhook settings verified:', {\r\n      storedUrl: verification.discordWebhookUrl ? `${verification.discordWebhookUrl.substring(0, 50)}...` : '(empty)',\r\n      storedEnabled: verification.discordWebhookEnabled\r\n    });\r\n  } catch (error) {\r\n    debug.error('Failed to save Discord webhook settings:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets Discord webhook settings\r\n */\r\nasync function getDiscordWebhookSettings() {\r\n  try {\r\n    const result = await browserAPI.storage.local.get([\r\n      'discordWebhookUrl',\r\n      'discordWebhookEnabled',\r\n      'discordServerName'\r\n    ]);\r\n    return {\r\n      webhookUrl: result.discordWebhookUrl || '',\r\n      enabled: result.discordWebhookEnabled !== false, // Default to true if URL exists\r\n      serverName: result.discordServerName || null\r\n    };\r\n  } catch (error) {\r\n    debug.error('Failed to get Discord webhook settings:', error);\r\n    return { webhookUrl: '', enabled: false, serverName: null };\r\n  }\r\n}\r\n\r\n/**\r\n * Tests a Discord webhook by sending a test message\r\n */\r\nasync function testDiscordWebhook(webhookUrl) {\r\n  try {\r\n    if (!webhookUrl || !webhookUrl.includes('discord.com/api/webhooks')) {\r\n      return { success: false, error: 'Invalid Discord webhook URL' };\r\n    }\r\n\r\n    const testEmbed = {\r\n      embeds: [{\r\n        title: '\uD83C\uDFB2 FoundCloud Connected!',\r\n        description: 'Discord webhook integration is working correctly.',\r\n        color: 0x4ECDC4, // Teal color matching the extension theme\r\n        footer: {\r\n          text: 'FoundCloud - Dice Cloud \u2192 Roll20 Bridge'\r\n        },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n\r\n    const response = await fetch(webhookUrl, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(testEmbed)\r\n    });\r\n\r\n    if (response.ok || response.status === 204) {\r\n      debug.log('\u2705 Discord webhook test successful');\r\n      return { success: true };\r\n    } else {\r\n      const errorText = await response.text();\r\n      debug.warn('\u274C Discord webhook test failed:', response.status, errorText);\r\n      return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Discord webhook test error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Posts a message to Discord via webhook\r\n * Rate limited to prevent spam (max 1 message per second)\r\n */\r\nlet lastDiscordPost = 0;\r\nconst DISCORD_RATE_LIMIT_MS = 1000;\r\n\r\nasync function postToDiscordWebhook(payload) {\r\n  try {\r\n    // Get webhook settings\r\n    const settings = await getDiscordWebhookSettings();\r\n\r\n    if (!settings.enabled || !settings.webhookUrl) {\r\n      debug.log('Discord webhook disabled or not configured');\r\n      return { success: false, error: 'Webhook not configured' };\r\n    }\r\n\r\n    // Rate limiting\r\n    const now = Date.now();\r\n    if (now - lastDiscordPost < DISCORD_RATE_LIMIT_MS) {\r\n      debug.log('Discord rate limit - skipping post');\r\n      return { success: false, error: 'Rate limited' };\r\n    }\r\n    lastDiscordPost = now;\r\n\r\n    // Build the Discord message\r\n    const message = buildDiscordMessage(payload);\r\n\r\n    const response = await fetch(settings.webhookUrl, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(message)\r\n    });\r\n\r\n    if (response.ok || response.status === 204) {\r\n      debug.log('\u2705 Posted to Discord:', payload.type);\r\n      return { success: true };\r\n    } else {\r\n      const errorText = await response.text();\r\n      debug.warn('\u274C Discord post failed:', response.status);\r\n      return { success: false, error: `HTTP ${response.status}` };\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Discord post error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Builds a Discord embed message from the payload\r\n * Messages are structured for both human readability and Pip Bot parsing\r\n *\r\n * Pip Bot can parse these fields:\r\n * - embed.title: Contains character name and event type\r\n * - embed.fields: Structured data (character, round, actions)\r\n * - embed.footer.text: Contains parseable metadata like \"TURN_START|Chepi|Round:3\"\r\n */\r\nfunction buildDiscordMessage(payload) {\r\n  const { type, characterName, combatant, round, actions, initiative } = payload;\r\n\r\n  // Action economy status icons\r\n  const getIcon = (used) => used ? '\u274C' : '\u2705';\r\n\r\n  // Build action status string\r\n  const buildActionStatus = (acts) => {\r\n    if (!acts) return null;\r\n    return [\r\n      `Action: ${getIcon(acts.action)}`,\r\n      `Bonus: ${getIcon(acts.bonus)}`,\r\n      `Move: ${getIcon(acts.movement)}`,\r\n      `React: ${getIcon(acts.reaction)}`\r\n    ].join(' | ');\r\n  };\r\n\r\n  // Build parseable footer for Pip Bot\r\n  const buildFooter = (eventType, charName, roundNum, acts) => {\r\n    const parts = [eventType, charName];\r\n    if (roundNum) parts.push(`Round:${roundNum}`);\r\n    if (acts) {\r\n      const actionBits = [\r\n        acts.action ? '0' : '1',\r\n        acts.bonus ? '0' : '1',\r\n        acts.movement ? '0' : '1',\r\n        acts.reaction ? '0' : '1'\r\n      ].join('');\r\n      parts.push(`Actions:${actionBits}`); // e.g., \"Actions:1111\" = all available\r\n    }\r\n    return parts.join('|');\r\n  };\r\n\r\n  if (type === 'turnStart') {\r\n    const actionStatus = buildActionStatus(actions);\r\n\r\n    return {\r\n      embeds: [{\r\n        title: `\uD83C\uDFB2 ${characterName}'s Turn`,\r\n        description: actionStatus || 'Combat turn started!',\r\n        color: 0x4ECDC4, // Teal - active turn\r\n        fields: [\r\n          { name: 'Character', value: characterName, inline: true },\r\n          ...(round ? [{ name: 'Round', value: String(round), inline: true }] : []),\r\n          ...(initiative ? [{ name: 'Initiative', value: String(initiative), inline: true }] : [])\r\n        ],\r\n        footer: { text: buildFooter('TURN_START', characterName, round, actions) },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n  }\r\n\r\n  if (type === 'turnEnd') {\r\n    return {\r\n      embeds: [{\r\n        title: `\u23F8\uFE0F ${characterName}'s Turn Ended`,\r\n        color: 0x95A5A6, // Gray - inactive\r\n        fields: [\r\n          { name: 'Character', value: characterName, inline: true }\r\n        ],\r\n        footer: { text: buildFooter('TURN_END', characterName, round) },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n  }\r\n\r\n  if (type === 'actionUpdate') {\r\n    const actionStatus = buildActionStatus(actions);\r\n    const hasUsedActions = actions && (actions.action || actions.bonus);\r\n\r\n    return {\r\n      embeds: [{\r\n        title: `\u2694\uFE0F ${characterName}`,\r\n        description: actionStatus,\r\n        color: hasUsedActions ? 0xF39C12 : 0x4ECDC4, // Orange if actions used, teal if available\r\n        fields: [\r\n          { name: 'Character', value: characterName, inline: true },\r\n          { name: 'Status', value: hasUsedActions ? 'Actions Used' : 'Actions Available', inline: true }\r\n        ],\r\n        footer: { text: buildFooter('ACTION_UPDATE', characterName, round, actions) },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n  }\r\n\r\n  if (type === 'combatStart') {\r\n    return {\r\n      embeds: [{\r\n        title: '\u2694\uFE0F Combat Started!',\r\n        description: combatant ? `First up: **${combatant}**` : 'Roll for initiative!',\r\n        color: 0xE74C3C, // Red - combat\r\n        footer: { text: 'COMBAT_START' },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n  }\r\n\r\n  if (type === 'roundChange') {\r\n    return {\r\n      embeds: [{\r\n        title: `\uD83D\uDD04 Round ${round}`,\r\n        description: combatant ? `Current turn: **${combatant}**` : 'New round begins!',\r\n        color: 0x9B59B6, // Purple - round change\r\n        footer: { text: `ROUND_CHANGE|Round:${round}` },\r\n        timestamp: new Date().toISOString()\r\n      }]\r\n    };\r\n  }\r\n\r\n  // Default simple message\r\n  return {\r\n    content: payload.message || `\uD83C\uDFB2 ${characterName || 'Unknown'}: ${type}`\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Discord User Linking\r\n// ============================================================================\r\n\r\n/**\r\n * Link Discord user info to auth_tokens table\r\n * This allows character sync to associate characters with Discord accounts\r\n * @param {string} discordUserId - The Discord user ID\r\n * @param {string} [discordUsername] - The Discord username\r\n * @param {string} [discordGlobalName] - The Discord display name\r\n */\r\nasync function linkDiscordUserToAuthTokens(discordUserId, discordUsername, discordGlobalName) {\r\n  if (!isSupabaseConfigured() || !discordUserId) {\r\n    debug.warn('Cannot link Discord user - Supabase not configured or no user ID');\r\n    return { success: false };\r\n  }\r\n\r\n  try {\r\n    // Generate browser fingerprint (same as SupabaseTokenManager)\r\n    const browserFingerprint = [\r\n      navigator.userAgent,\r\n      navigator.language,\r\n      screen.width + 'x' + screen.height,\r\n      new Date().getTimezoneOffset()\r\n    ].join('|');\r\n    let hash = 0;\r\n    for (let i = 0; i < browserFingerprint.length; i++) {\r\n      const char = browserFingerprint.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    const visitorId = 'user_' + Math.abs(hash).toString(36);\r\n\r\n    debug.log('\uD83D\uDD17 Linking Discord user to auth_tokens:', discordUserId, discordUsername, discordGlobalName, 'for browser:', visitorId);\r\n\r\n    // Build update payload with all available Discord fields\r\n    const updatePayload = {\r\n      discord_user_id: discordUserId,\r\n      updated_at: new Date().toISOString()\r\n    };\r\n    if (discordUsername) {\r\n      updatePayload.discord_username = discordUsername;\r\n    }\r\n    if (discordGlobalName) {\r\n      updatePayload.discord_global_name = discordGlobalName;\r\n    }\r\n\r\n    // Update auth_tokens with Discord info\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/auth_tokens?user_id=eq.${visitorId}`,\r\n      {\r\n        method: 'PATCH',\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n          'Content-Type': 'application/json',\r\n          'Prefer': 'return=minimal'\r\n        },\r\n        body: JSON.stringify(updatePayload)\r\n      }\r\n    );\r\n\r\n    if (response.ok) {\r\n      debug.log('\u2705 Discord user linked to auth_tokens');\r\n\r\n      // Also update any existing characters with this user's DiceCloud ID\r\n      const authResult = await browserAPI.storage.local.get(['diceCloudUserId']);\r\n      if (authResult.diceCloudUserId) {\r\n        await linkDiscordUserToCharacters(discordUserId, authResult.diceCloudUserId);\r\n      }\r\n\r\n      return { success: true };\r\n    } else {\r\n      const errorText = await response.text();\r\n      debug.error('\u274C Failed to link Discord user:', response.status, errorText);\r\n      return { success: false, error: errorText };\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Error linking Discord user:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Update existing characters with the Discord user ID\r\n */\r\nasync function linkDiscordUserToCharacters(discordUserId, diceCloudUserId) {\r\n  if (!isSupabaseConfigured()) return;\r\n\r\n  try {\r\n    debug.log('\uD83D\uDD17 Linking Discord user to existing characters:', discordUserId);\r\n\r\n    // Update characters that have user_id_dicecloud matching but discord_user_id is 'not_linked'\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_characters?user_id_dicecloud=eq.${diceCloudUserId}&discord_user_id=eq.not_linked`,\r\n      {\r\n        method: 'PATCH',\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n          'Content-Type': 'application/json',\r\n          'Prefer': 'return=minimal'\r\n        },\r\n        body: JSON.stringify({\r\n          discord_user_id: discordUserId,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n      }\r\n    );\r\n\r\n    if (response.ok) {\r\n      debug.log('\u2705 Updated existing characters with Discord user ID');\r\n    } else {\r\n      debug.warn('\u26A0\uFE0F Could not update existing characters:', response.status);\r\n    }\r\n  } catch (error) {\r\n    debug.warn('\u26A0\uFE0F Error updating existing characters:', error);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Character Cloud Sync to Supabase\r\n// ============================================================================\r\n\r\n/**\r\n * Store character data in Supabase for cloud sync\r\n * This allows character data to be accessed by the Discord bot\r\n */\r\nasync function storeCharacterToCloud(characterData, pairingCode = null) {\r\n  if (!isSupabaseConfigured()) {\r\n    debug.warn('Supabase not configured - character sync unavailable');\r\n    return {\r\n      success: false,\r\n      error: 'Cloud sync not available. Supabase not configured.',\r\n      supabaseNotConfigured: true\r\n    };\r\n  }\r\n\r\n  try {\r\n    debug.log('\uD83C\uDFAD Storing character in Supabase:', characterData.name || characterData.id);\r\n\r\n    // Generate a browser ID for looking up auth tokens\r\n    const browserFingerprint = [\r\n      navigator.userAgent,\r\n      navigator.language,\r\n      screen.width + 'x' + screen.height,\r\n      new Date().getTimezoneOffset()\r\n    ].join('|');\r\n    let hash = 0;\r\n    for (let i = 0; i < browserFingerprint.length; i++) {\r\n      const char = browserFingerprint.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    const visitorId = 'user_' + Math.abs(hash).toString(36);\r\n\r\n    // Get DiceCloud user ID from character data, or fall back to local storage\r\n    let dicecloudUserId = characterData.dicecloudUserId || characterData.userId || null;\r\n    if (!dicecloudUserId) {\r\n      const stored = await browserAPI.storage.local.get(['diceCloudUserId']);\r\n      dicecloudUserId = stored.diceCloudUserId || null;\r\n      if (dicecloudUserId) {\r\n        debug.log('\u2705 Got DiceCloud user ID from storage:', dicecloudUserId);\r\n      }\r\n    }\r\n\r\n    const payload = {\r\n      user_id_dicecloud: dicecloudUserId,\r\n      dicecloud_character_id: characterData.id,\r\n      character_name: characterData.name || 'Unknown',\r\n      race: characterData.race || null,\r\n      class: characterData.class || null,\r\n      level: characterData.level || 1,\r\n      alignment: characterData.alignment || null,\r\n      hit_points: characterData.hitPoints || { current: 0, max: 0 },\r\n      hit_dice: characterData.hitDice || { current: 0, max: 0, type: 'd8' },\r\n      temporary_hp: characterData.temporaryHP || 0,\r\n      death_saves: characterData.deathSaves || { successes: 0, failures: 0 },\r\n      inspiration: characterData.inspiration || false,\r\n      armor_class: characterData.armorClass || 10,\r\n      speed: characterData.speed || 30,\r\n      initiative: characterData.initiative || 0,\r\n      proficiency_bonus: characterData.proficiencyBonus || 2,\r\n      attributes: characterData.attributes || {},\r\n      attribute_mods: characterData.attributeMods || {},\r\n      saves: characterData.saves || {},\r\n      skills: characterData.skills || {},\r\n      spell_slots: characterData.spellSlots || {},\r\n      resources: characterData.resources || [],\r\n      conditions: characterData.conditions || [],\r\n      // Store the FULL parsed character object so it can be rebuilt exactly\r\n      // The individual fields above are for Discord bot quick access\r\n      raw_dicecloud_data: characterData,\r\n      updated_at: new Date().toISOString()\r\n    };\r\n\r\n    // If pairing code provided, look up the pairing to link\r\n    if (pairingCode) {\r\n      const pairingResponse = await fetch(\r\n        `${SUPABASE_URL}/rest/v1/rollcloud_pairings?pairing_code=eq.${pairingCode}&select=id,discord_user_id`,\r\n        {\r\n          headers: {\r\n            'apikey': SUPABASE_ANON_KEY,\r\n            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n          }\r\n        }\r\n      );\r\n      if (pairingResponse.ok) {\r\n        const pairings = await pairingResponse.json();\r\n        if (pairings.length > 0) {\r\n          payload.pairing_id = pairings[0].id;\r\n          payload.discord_user_id = pairings[0].discord_user_id;\r\n          debug.log('\u2705 Linked to pairing:', pairings[0].id);\r\n        }\r\n      }\r\n    } else {\r\n      // No pairing code provided - try multiple sources for Discord user ID\r\n      let discordUserId = null;\r\n\r\n      // 1. First check auth_tokens\r\n      try {\r\n        const authResponse = await fetch(\r\n          `${SUPABASE_URL}/rest/v1/auth_tokens?user_id=eq.${visitorId}&select=discord_user_id`,\r\n          {\r\n            headers: {\r\n              'apikey': SUPABASE_ANON_KEY,\r\n              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n            }\r\n          }\r\n        );\r\n        if (authResponse.ok) {\r\n          const authTokens = await authResponse.json();\r\n          if (authTokens.length > 0 && authTokens[0].discord_user_id) {\r\n            discordUserId = authTokens[0].discord_user_id;\r\n            debug.log('\u2705 Found Discord user ID from auth_tokens:', discordUserId);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        debug.warn('\u26A0\uFE0F Failed to check auth_tokens:', error.message);\r\n      }\r\n\r\n      // 2. If not in auth_tokens, check pairings table for this DiceCloud user\r\n      if (!discordUserId && payload.user_id_dicecloud) {\r\n        try {\r\n          const pairingResponse = await fetch(\r\n            `${SUPABASE_URL}/rest/v1/rollcloud_pairings?dicecloud_user_id=eq.${payload.user_id_dicecloud}&status=eq.connected&select=discord_user_id,discord_username,discord_global_name`,\r\n            {\r\n              headers: {\r\n                'apikey': SUPABASE_ANON_KEY,\r\n                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n              }\r\n            }\r\n          );\r\n          if (pairingResponse.ok) {\r\n            const pairings = await pairingResponse.json();\r\n            if (pairings.length > 0 && pairings[0].discord_user_id) {\r\n              discordUserId = pairings[0].discord_user_id;\r\n              debug.log('\u2705 Found Discord user ID from pairings:', discordUserId);\r\n              // Also update auth_tokens so future lookups are faster\r\n              await linkDiscordUserToAuthTokens(\r\n                discordUserId,\r\n                pairings[0].discord_username,\r\n                pairings[0].discord_global_name\r\n              );\r\n            }\r\n          }\r\n        } catch (error) {\r\n          debug.warn('\u26A0\uFE0F Failed to check pairings:', error.message);\r\n        }\r\n      }\r\n\r\n      // 3. If still not found, check local storage for saved pairing ID\r\n      if (!discordUserId) {\r\n        try {\r\n          const stored = await browserAPI.storage.local.get(['discordPairingId']);\r\n          if (stored.discordPairingId) {\r\n            const pairingResponse = await fetch(\r\n              `${SUPABASE_URL}/rest/v1/rollcloud_pairings?id=eq.${stored.discordPairingId}&select=discord_user_id,discord_username,discord_global_name`,\r\n              {\r\n                headers: {\r\n                  'apikey': SUPABASE_ANON_KEY,\r\n                  'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n                }\r\n              }\r\n            );\r\n            if (pairingResponse.ok) {\r\n              const pairings = await pairingResponse.json();\r\n              if (pairings.length > 0 && pairings[0].discord_user_id) {\r\n                discordUserId = pairings[0].discord_user_id;\r\n                debug.log('\u2705 Found Discord user ID from stored pairing:', discordUserId);\r\n                // Also update auth_tokens with all Discord info\r\n                await linkDiscordUserToAuthTokens(\r\n                  discordUserId,\r\n                  pairings[0].discord_username,\r\n                  pairings[0].discord_global_name\r\n                );\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          debug.warn('\u26A0\uFE0F Failed to check stored pairing:', error.message);\r\n        }\r\n      }\r\n\r\n      payload.discord_user_id = discordUserId || 'not_linked';\r\n      if (!discordUserId) {\r\n        debug.log('\u26A0\uFE0F No Discord user ID found from any source, using placeholder');\r\n      }\r\n    }\r\n\r\n    debug.log('\uD83D\uDCE4 Sending character payload to Supabase:', payload.character_name);\r\n\r\n    // Try POST first (insert)\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_characters`,\r\n      {\r\n        method: 'POST',\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n          'Content-Type': 'application/json',\r\n          'Prefer': 'resolution=merge-duplicates,return=minimal'\r\n        },\r\n        body: JSON.stringify(payload)\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      debug.log('\u26A0\uFE0F Character POST failed, trying PATCH:', response.status, errorText);\r\n\r\n      // Try PATCH (update) instead\r\n      const updateResponse = await fetch(\r\n        `${SUPABASE_URL}/rest/v1/rollcloud_characters?dicecloud_character_id=eq.${characterData.id}`,\r\n        {\r\n          method: 'PATCH',\r\n          headers: {\r\n            'apikey': SUPABASE_ANON_KEY,\r\n            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n            'Content-Type': 'application/json',\r\n            'Prefer': 'return=minimal'\r\n          },\r\n          body: JSON.stringify(payload)\r\n        }\r\n      );\r\n\r\n      if (!updateResponse.ok) {\r\n        const patchError = await updateResponse.text();\r\n        debug.error('\u274C Character PATCH also failed:', updateResponse.status, patchError);\r\n        throw new Error(`Character update failed: ${patchError}`);\r\n      }\r\n      debug.log('\u2705 Character updated via PATCH');\r\n    } else {\r\n      debug.log('\u2705 Character inserted via POST');\r\n    }\r\n\r\n    debug.log('\u2705 Character stored in Supabase:', characterData.name);\r\n    return { success: true };\r\n  } catch (error) {\r\n    debug.error('\u274C Failed to store character in Supabase:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Sync character color to Supabase\r\n * Updates only the notification_color field for a specific character\r\n */\r\nasync function syncCharacterColorToSupabase(characterId, color) {\r\n  if (!isSupabaseConfigured()) {\r\n    debug.warn('Supabase not configured - color sync unavailable');\r\n    return {\r\n      success: false,\r\n      error: 'Color sync not available. Supabase not configured.',\r\n      supabaseNotConfigured: true\r\n    };\r\n  }\r\n\r\n  try {\r\n    debug.log('\uD83C\uDFA8 Syncing character color to Supabase:', characterId, color);\r\n\r\n    // Update only the notification_color field\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_characters?dicecloud_character_id=eq.${characterId}`,\r\n      {\r\n        method: 'PATCH',\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n          'Content-Type': 'application/json',\r\n          'Prefer': 'return=minimal'\r\n        },\r\n        body: JSON.stringify({\r\n          notification_color: color\r\n        })\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      debug.error('\u274C Failed to sync color to Supabase:', response.status, errorText);\r\n      return { success: false, error: `Sync failed: ${response.status}` };\r\n    }\r\n\r\n    debug.log('\u2705 Character color synced to Supabase successfully');\r\n    return { success: true };\r\n  } catch (error) {\r\n    debug.error('\u274C Failed to sync character color to Supabase:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if character is currently active in Discord bot instances\r\n * This calls the pip-bot's character status API\r\n */\r\nasync function checkDiscordCharacterIntegration(characterName, characterId) {\r\n  try {\r\n    debug.log(`\uD83D\uDD0D Checking Discord integration for character: ${characterName} (${characterId})`);\r\n    \r\n    // Check for both webhook and pairing-based integration\r\n    const webhookResult = await getDiscordWebhookSettings();\r\n    const pairingResult = await browserAPI.storage.local.get(['discordPairingId', 'discordPairingCode']);\r\n    \r\n    debug.log(`\uD83D\uDD0D Webhook result:`, { hasUrl: !!webhookResult.webhookUrl, enabled: webhookResult.enabled });\r\n    debug.log(`\uD83D\uDD0D Pairing result:`, { hasPairingId: !!pairingResult.discordPairingId, hasCode: !!pairingResult.discordPairingCode });\r\n    \r\n    // Check if either webhook or pairing is configured\r\n    const hasWebhookIntegration = webhookResult.webhookUrl && webhookResult.enabled;\r\n    const hasPairingIntegration = pairingResult.discordPairingId || pairingResult.discordPairingCode;\r\n    \r\n    if (!hasWebhookIntegration && !hasPairingIntegration) {\r\n      debug.log('\u274C Discord integration not configured - no webhook or pairing found');\r\n      return {\r\n        success: true,\r\n        found: false,\r\n        serverName: null,\r\n        message: 'Discord integration not configured'\r\n      };\r\n    }\r\n    \r\n    let serverName = webhookResult.serverName;\r\n    \r\n    if (hasWebhookIntegration) {\r\n      // Extract Discord server info from webhook URL\r\n      // Webhook URL format: https://discord.com/api/webhooks/{bot_id}/{token}\r\n      const webhookUrl = new URL(webhookResult.webhookUrl);\r\n      const botId = webhookUrl.pathname.split('/')[2];\r\n      \r\n      debug.log(`\uD83E\uDD16 Checking with bot ID: ${botId} for character: ${characterName}`);\r\n    } else if (hasPairingIntegration) {\r\n      debug.log(`\uD83E\uDD16 Checking with pairing system for character: ${characterName}`);\r\n      serverName = 'Discord Server (Paired)';\r\n    }\r\n    \r\n    // Get active character data to compare\r\n    const characterData = await getCharacterData();\r\n    // Handle both DiceCloud format (name) and database format (character_name)\r\n    const activeCharacterName = characterData?.character_name || characterData?.name;\r\n\r\n    if (characterData && activeCharacterName === characterName) {\r\n      debug.log(`\u2705 Character ${characterName} found in local storage and matches Discord integration`);\r\n\r\n      return {\r\n        success: true,\r\n        found: true,\r\n        serverName: serverName || 'Unknown Server',\r\n        message: `Character ${characterName} is active in Discord server: ${serverName || 'Unknown Server'}`,\r\n        characterData: {\r\n          name: activeCharacterName,\r\n          race: characterData.race,\r\n          class: characterData.class,\r\n          level: characterData.level,\r\n          discordServer: serverName\r\n        }\r\n      };\r\n    } else {\r\n      debug.log(`\u274C Character ${characterName} not found in local storage or doesn't match active character`);\r\n\r\n      return {\r\n        success: true,\r\n        found: false,\r\n        serverName: null,\r\n        message: `Character ${characterName} is not currently active in Discord`,\r\n        availableCharacter: characterData ? {\r\n          name: activeCharacterName,\r\n          race: characterData.race,\r\n          class: characterData.class,\r\n          level: characterData.level\r\n        } : null\r\n      };\r\n    }\r\n    \r\n  } catch (error) {\r\n    debug.error('\u274C Error checking Discord character integration:', error);\r\n    return {\r\n      success: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch data from DiceCloud API\r\n * Used by Roll20 content script to get character data\r\n */\r\nasync function fetchFromDiceCloudAPI(url, token) {\r\n  try {\r\n    debug.log('\uD83D\uDD0C Fetching from DiceCloud API:', url);\r\n\r\n    const headers = {\r\n      'Content-Type': 'application/json'\r\n    };\r\n\r\n    if (token) {\r\n      headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n\r\n    const response = await fetch(url, {\r\n      method: 'GET',\r\n      headers: headers\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      debug.error('\u274C DiceCloud API fetch failed:', response.status, errorText);\r\n      return { success: false, error: `API error: ${response.status}` };\r\n    }\r\n\r\n    const data = await response.json();\r\n    debug.log('\u2705 DiceCloud API fetch successful');\r\n    return { success: true, data: data };\r\n  } catch (error) {\r\n    debug.error('\u274C Failed to fetch from DiceCloud API:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Discord Pairing via Supabase\r\n// ============================================================================\r\n\r\n/**\r\n * Check if Supabase is configured\r\n */\r\nfunction isSupabaseConfigured() {\r\n  return SUPABASE_URL &&\r\n         !SUPABASE_URL.includes('your-project') &&\r\n         SUPABASE_ANON_KEY &&\r\n         SUPABASE_ANON_KEY !== 'your-anon-key';\r\n}\r\n\r\n// ============================================================================\r\n// Supabase Realtime Subscription for Pairing Updates\r\n// ============================================================================\r\n\r\nlet realtimeSocket = null;\r\nlet realtimeHeartbeat = null;\r\nlet currentPairingCode = null;\r\n\r\n/**\r\n * Subscribe to Realtime updates for a pairing code\r\n * When the Discord bot completes the pairing, we'll get notified immediately\r\n */\r\nfunction subscribeToRealtimePairing(pairingCode) {\r\n  if (!isSupabaseConfigured()) {\r\n    debug.warn('Cannot subscribe to Realtime - Supabase not configured');\r\n    return;\r\n  }\r\n\r\n  // Store the pairing code we're watching\r\n  currentPairingCode = pairingCode;\r\n\r\n  // Close existing connection if any\r\n  if (realtimeSocket) {\r\n    realtimeSocket.close();\r\n  }\r\n\r\n  // Extract project ref from URL\r\n  const projectRef = SUPABASE_URL.replace('https://', '').split('.')[0];\r\n  const wsUrl = `wss://${projectRef}.supabase.co/realtime/v1/websocket?apikey=${SUPABASE_ANON_KEY}&vsn=1.0.0`;\r\n\r\n  debug.log('\uD83D\uDD0C Connecting to Supabase Realtime for pairing:', pairingCode);\r\n\r\n  try {\r\n    realtimeSocket = new WebSocket(wsUrl);\r\n\r\n    realtimeSocket.onopen = () => {\r\n      debug.log('\u2705 Realtime WebSocket connected');\r\n\r\n      // Send join message to subscribe to pairing updates\r\n      const joinMessage = {\r\n        topic: `realtime:public:rollcloud_pairings:pairing_code=eq.${pairingCode}`,\r\n        event: 'phx_join',\r\n        payload: {\r\n          config: {\r\n            broadcast: { self: false },\r\n            presence: { key: '' },\r\n            postgres_changes: [{\r\n              event: 'UPDATE',\r\n              schema: 'public',\r\n              table: 'rollcloud_pairings',\r\n              filter: `pairing_code=eq.${pairingCode}`\r\n            }]\r\n          }\r\n        },\r\n        ref: '1'\r\n      };\r\n      realtimeSocket.send(JSON.stringify(joinMessage));\r\n\r\n      // Start heartbeat to keep connection alive\r\n      realtimeHeartbeat = setInterval(() => {\r\n        if (realtimeSocket && realtimeSocket.readyState === WebSocket.OPEN) {\r\n          realtimeSocket.send(JSON.stringify({\r\n            topic: 'phoenix',\r\n            event: 'heartbeat',\r\n            payload: {},\r\n            ref: Date.now().toString()\r\n          }));\r\n        }\r\n      }, 30000);\r\n    };\r\n\r\n    realtimeSocket.onmessage = async (event) => {\r\n      try {\r\n        const message = JSON.parse(event.data);\r\n        debug.log('\uD83D\uDCE8 Realtime message:', message.event);\r\n\r\n        // Handle postgres_changes events\r\n        if (message.event === 'postgres_changes' && message.payload?.data?.record) {\r\n          const record = message.payload.data.record;\r\n\r\n          // Check if pairing was completed\r\n          if (record.status === 'connected' && record.discord_user_id) {\r\n            debug.log('\uD83C\uDF89 Pairing completed via Realtime! Discord user:', record.discord_user_id);\r\n\r\n            // Update auth_tokens with full Discord info\r\n            await linkDiscordUserToAuthTokens(\r\n              record.discord_user_id,\r\n              record.discord_username,\r\n              record.discord_global_name\r\n            );\r\n\r\n            // IMPORTANT: Save webhook settings directly - don't rely on popup being open\r\n            if (record.webhook_url) {\r\n              debug.log('\uD83D\uDCDD Saving webhook URL from Realtime:', record.webhook_url.substring(0, 50) + '...');\r\n              await setDiscordWebhookSettings(record.webhook_url, true, record.discord_guild_name);\r\n\r\n              // Also save pairing ID for command polling\r\n              await browserAPI.storage.local.set({\r\n                currentPairingId: record.id,\r\n                discordPairingId: record.id\r\n              });\r\n\r\n              // Subscribe to command realtime\r\n              subscribeToCommandRealtime(record.id);\r\n              debug.log('\u2705 Discord webhook and pairing ID saved from Realtime');\r\n            }\r\n\r\n            // Notify popup that pairing is complete (if it's open)\r\n            try {\r\n              await browserAPI.runtime.sendMessage({\r\n                action: 'pairingComplete',\r\n                discordUserId: record.discord_user_id,\r\n                discordUsername: record.discord_username,\r\n                discordGlobalName: record.discord_global_name,\r\n                webhookUrl: record.webhook_url,\r\n                serverName: record.discord_guild_name,\r\n                pairingId: record.id\r\n              });\r\n            } catch (e) {\r\n              // Popup might not be open - but webhook is already saved above\r\n              debug.log('Could not notify popup (probably not open)');\r\n            }\r\n\r\n            // Clean up subscription\r\n            unsubscribeFromRealtimePairing();\r\n          }\r\n        }\r\n      } catch (e) {\r\n        debug.warn('Error processing Realtime message:', e);\r\n      }\r\n    };\r\n\r\n    realtimeSocket.onerror = (error) => {\r\n      debug.warn('Realtime WebSocket error:', error);\r\n    };\r\n\r\n    realtimeSocket.onclose = () => {\r\n      debug.log('\uD83D\uDD0C Realtime WebSocket closed');\r\n      if (realtimeHeartbeat) {\r\n        clearInterval(realtimeHeartbeat);\r\n        realtimeHeartbeat = null;\r\n      }\r\n    };\r\n  } catch (error) {\r\n    debug.error('Failed to connect to Realtime:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Unsubscribe from Realtime updates\r\n */\r\nfunction unsubscribeFromRealtimePairing() {\r\n  if (realtimeSocket) {\r\n    realtimeSocket.close();\r\n    realtimeSocket = null;\r\n  }\r\n  if (realtimeHeartbeat) {\r\n    clearInterval(realtimeHeartbeat);\r\n    realtimeHeartbeat = null;\r\n  }\r\n  currentPairingCode = null;\r\n  debug.log('\uD83D\uDD0C Unsubscribed from Realtime pairing updates');\r\n}\r\n\r\n// Before creating new pairing, expire old ones\r\nasync function createPairing(code, username, userId) {\r\n  // Clean up old pairings for this user\r\n  await supabase\r\n    .from('rollcloud_pairings')\r\n    .update({ status: 'expired' })\r\n    .eq('dicecloud_user_id', userId)\r\n    .eq('status', 'connected');\r\n  \r\n  // NOW create the new one\r\n  const { data } = await supabase\r\n    .from('rollcloud_pairings')\r\n    .insert({\r\n      pairing_code: code,\r\n      dicecloud_username: username,\r\n      dicecloud_user_id: userId,\r\n      status: 'pending'\r\n    });\r\n}\r\n\r\n/**\r\n * Create a Discord pairing code in Supabase\r\n */\r\nasync function createDiscordPairing(code, diceCloudUsername, diceCloudUserId) {\r\n  // Check if Supabase is configured\r\n  if (!isSupabaseConfigured()) {\r\n    debug.warn('Supabase not configured - pairing unavailable');\r\n    return {\r\n      success: false,\r\n      error: 'Automatic pairing not available. Please use manual webhook setup.',\r\n      supabaseNotConfigured: true\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Expire ALL existing pairings for this DiceCloud user (both pending and connected)\r\n    // This ensures only one active pairing exists per user at a time\r\n    if (diceCloudUserId) {\r\n      try {\r\n        const expireResponse = await fetch(\r\n          `${SUPABASE_URL}/rest/v1/rollcloud_pairings?dicecloud_user_id=eq.${diceCloudUserId}&status=in.(pending,connected)`,\r\n          {\r\n            method: 'PATCH',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              'apikey': SUPABASE_ANON_KEY,\r\n              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n              'Prefer': 'return=minimal'\r\n            },\r\n            body: JSON.stringify({ status: 'expired' })\r\n          }\r\n        );\r\n        if (expireResponse.ok) {\r\n          debug.log('\uD83E\uDDF9 Expired old pairings (pending + connected) for user:', diceCloudUserId);\r\n        }\r\n      } catch (expireError) {\r\n        debug.warn('\u26A0\uFE0F Could not expire old pairings:', expireError.message);\r\n        // Continue anyway - this is not critical\r\n      }\r\n    }\r\n\r\n    const response = await fetch(`${SUPABASE_URL}/rest/v1/rollcloud_pairings`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'apikey': SUPABASE_ANON_KEY,\r\n        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n        'Prefer': 'return=representation'\r\n      },\r\n      body: JSON.stringify({\r\n        pairing_code: code,\r\n        dicecloud_username: diceCloudUsername,\r\n        dicecloud_user_id: diceCloudUserId, // Store the actual DiceCloud user ID (Meteor ID)\r\n        status: 'pending'\r\n      })\r\n    });\r\n\r\n    if (response.ok) {\r\n      debug.log('\u2705 Discord pairing created:', code, 'for DiceCloud user:', diceCloudUserId);\r\n\r\n      // Subscribe to Realtime updates for this pairing code\r\n      // This will notify us immediately when the Discord bot completes the pairing\r\n      subscribeToRealtimePairing(code);\r\n\r\n      return { success: true, code };\r\n    } else {\r\n      const error = await response.text();\r\n      debug.error('\u274C Failed to create pairing:', error);\r\n      return { success: false, error: 'Failed to create pairing code' };\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Supabase error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a Discord pairing has been completed (webhook URL filled in)\r\n */\r\nasync function checkDiscordPairing(code) {\r\n  // Check if Supabase is configured\r\n  if (!isSupabaseConfigured()) {\r\n    return { success: false, error: 'Supabase not configured', supabaseNotConfigured: true };\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_pairings?pairing_code=eq.${code}&select=*`,\r\n      {\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n        }\r\n      }\r\n    );\r\n\r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      if (data.length > 0) {\r\n        const pairing = data[0];\r\n        if (pairing.status === 'connected' && pairing.webhook_url) {\r\n          debug.log('\u2705 Discord pairing connected!');\r\n          return {\r\n            success: true,\r\n            connected: true,\r\n            webhookUrl: pairing.webhook_url,\r\n            serverName: pairing.discord_guild_name,\r\n            pairingId: pairing.id, // Return pairing ID for command polling\r\n            discordUserId: pairing.discord_user_id, // Return Discord user ID to link to auth_tokens\r\n            discordUsername: pairing.discord_username,\r\n            discordGlobalName: pairing.discord_global_name\r\n          };\r\n        } else {\r\n          return { success: true, connected: false };\r\n        }\r\n      } else {\r\n        return { success: false, error: 'Pairing code not found' };\r\n      }\r\n    } else {\r\n      return { success: false, error: 'Failed to check pairing' };\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Supabase check error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Discord Command Realtime Subscription (Discord \u2192 Extension \u2192 Roll20)\r\n// ============================================================================\r\n\r\nlet commandRealtimeSocket = null;\r\nlet commandRealtimeHeartbeat = null;\r\nlet currentPairingId = null;\r\nlet commandRealtimeReconnectTimeout = null;\r\n\r\n/**\r\n * CORRECTED subscribeToCommandRealtime function\r\n * Replace the existing function in background.js with this\r\n */\r\n\r\nasync function subscribeToCommandRealtime(pairingId) {\r\n  if (!pairingId) {\r\n    const settings = await browserAPI.storage.local.get(['discordPairingId']);\r\n    pairingId = settings.discordPairingId;\r\n  }\r\n\r\n  if (!pairingId) {\r\n    debug.warn('No pairing ID available for command subscription');\r\n    return;\r\n  }\r\n\r\n  if (!isSupabaseConfigured()) {\r\n    debug.warn('Supabase not configured \u2014 cannot subscribe to commands');\r\n    return;\r\n  }\r\n\r\n  // If already subscribed with same pairing, skip\r\n  if (commandRealtimeSocket && commandRealtimeSocket.readyState === WebSocket.OPEN && currentPairingId === pairingId) {\r\n    debug.log('Command realtime already connected for pairing:', pairingId);\r\n    return;\r\n  }\r\n\r\n  // Tear down any existing connection first\r\n  unsubscribeFromCommandRealtime();\r\n\r\n  currentPairingId = pairingId;\r\n\r\n  const projectRef = SUPABASE_URL.replace('https://', '').split('.')[0];\r\n  const wsUrl = `wss://${projectRef}.supabase.co/realtime/v1/websocket?apikey=${SUPABASE_ANON_KEY}&vsn=1.0.0`;\r\n\r\n  debug.log('\uD83D\uDD0C Connecting to Supabase Realtime for commands, pairing:', pairingId);\r\n\r\n  try {\r\n    commandRealtimeSocket = new WebSocket(wsUrl);\r\n\r\n    commandRealtimeSocket.onopen = () => {\r\n      debug.log('\u2705 Command Realtime WebSocket connected');\r\n\r\n      // CORRECTED: Subscribe to postgres_changes for INSERT events on rollcloud_commands\r\n      const topic = `realtime:public:rollcloud_commands`;\r\n      const joinMessage = {\r\n        topic: topic,\r\n        event: 'phx_join',\r\n        payload: {\r\n          config: {\r\n            postgres_changes: [{\r\n              event: 'INSERT',  // \u2705 Listen for new commands being inserted\r\n              schema: 'public',\r\n              table: 'rollcloud_commands',  // \u2705 Correct table\r\n              filter: `pairing_id=eq.${pairingId}`  // \u2705 Only this pairing's commands\r\n            }]\r\n          }\r\n        },\r\n        ref: 'cmd_1'\r\n      };\r\n      \r\n      debug.log('\uD83D\uDCE4 Subscribing to postgres_changes:', JSON.stringify(joinMessage, null, 2));\r\n      commandRealtimeSocket.send(JSON.stringify(joinMessage));\r\n\r\n      // Heartbeat every 30s to keep connection alive\r\n      commandRealtimeHeartbeat = setInterval(() => {\r\n        if (commandRealtimeSocket && commandRealtimeSocket.readyState === WebSocket.OPEN) {\r\n          commandRealtimeSocket.send(JSON.stringify({\r\n            topic: 'phoenix',\r\n            event: 'heartbeat',\r\n            payload: {},\r\n            ref: 'cmd_hb_' + Date.now()\r\n          }));\r\n        }\r\n      }, 30000);\r\n\r\n      // Also drain any pending commands that arrived while we were disconnected\r\n      drainPendingCommands();\r\n    };\r\n\r\n    commandRealtimeSocket.onmessage = async (event) => {\r\n      try {\r\n        const message = JSON.parse(event.data);\r\n\r\n        // Log ALL raw messages for debugging\r\n        debug.log('\uD83D\uDCE8 RAW Realtime message:', JSON.stringify(message).substring(0, 500));\r\n\r\n        // Handle Phoenix protocol replies (subscription confirmation)\r\n        if (message.event === 'phx_reply') {\r\n          if (message.payload?.status === 'ok') {\r\n            debug.log('\u2705 Realtime subscription confirmed for topic:', message.topic || 'unknown');\r\n          } else {\r\n            debug.error('\u274C Realtime subscription FAILED:', message.payload?.response || message.payload);\r\n          }\r\n          return;\r\n        }\r\n\r\n        // Handle system messages\r\n        if (message.event === 'system' && message.payload?.status === 'ok') {\r\n          debug.log('\u2705 Realtime system ready:', message.payload?.message || 'connected');\r\n          return;\r\n        }\r\n\r\n        // \u2705 CORRECTED: Handle postgres_changes events (not broadcast)\r\n        if (message.event === 'postgres_changes') {\r\n          const payload = message.payload;\r\n          \r\n          debug.log('\uD83D\uDCE5 postgres_changes event received:', payload?.data?.type || 'unknown type');\r\n\r\n          // For INSERT events, the new record is in payload.data.record\r\n          if (payload?.data?.type === 'INSERT' && payload.data.record) {\r\n            const record = payload.data.record;\r\n            \r\n            debug.log('\uD83D\uDCE5 New command inserted! Type:', record.command_type, 'ID:', record.id);\r\n\r\n            // Only process if status is pending\r\n            if (record.status === 'pending') {\r\n              debug.log('\u26A1 Executing command:', record.command_type);\r\n              await executeCommand(record);\r\n            } else {\r\n              debug.log('\u23ED\uFE0F Skipping command with status:', record.status);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        // Still handle broadcast events as fallback (if you add that later)\r\n        if (message.event === 'broadcast') {\r\n          const record = message.payload?.record ?? message.payload?.new ?? message.payload;\r\n\r\n          debug.log('\uD83D\uDCE5 Broadcast received! Record:', JSON.stringify(record).substring(0, 300));\r\n\r\n          if (record && record.status === 'pending') {\r\n            debug.log('\uD83D\uDCE5 Realtime command received via broadcast:', record.command_type, record.id);\r\n            await executeCommand(record);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        debug.warn('Error processing command Realtime message:', e);\r\n      }\r\n    };\r\n\r\n    commandRealtimeSocket.onerror = (error) => {\r\n      debug.warn('Command Realtime WebSocket error:', error);\r\n    };\r\n\r\n    commandRealtimeSocket.onclose = () => {\r\n      debug.log('\uD83D\uDD0C Command Realtime WebSocket closed');\r\n      if (commandRealtimeHeartbeat) {\r\n        clearInterval(commandRealtimeHeartbeat);\r\n        commandRealtimeHeartbeat = null;\r\n      }\r\n\r\n      // Auto-reconnect after 5 seconds if we still have a pairing\r\n      if (currentPairingId) {\r\n        debug.log('\u23F3 Scheduling command realtime reconnect in 5s...');\r\n        commandRealtimeReconnectTimeout = setTimeout(() => {\r\n          if (currentPairingId) {\r\n            subscribeToCommandRealtime(currentPairingId);\r\n          }\r\n        }, 5000);\r\n      }\r\n    };\r\n  } catch (error) {\r\n    debug.error('Failed to connect to command Realtime:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Unsubscribe from command Realtime updates\r\n */\r\nfunction unsubscribeFromCommandRealtime() {\r\n  if (commandRealtimeReconnectTimeout) {\r\n    clearTimeout(commandRealtimeReconnectTimeout);\r\n    commandRealtimeReconnectTimeout = null;\r\n  }\r\n  if (commandRealtimeSocket) {\r\n    commandRealtimeSocket.close();\r\n    commandRealtimeSocket = null;\r\n  }\r\n  if (commandRealtimeHeartbeat) {\r\n    clearInterval(commandRealtimeHeartbeat);\r\n    commandRealtimeHeartbeat = null;\r\n  }\r\n  debug.log('\uD83D\uDD07 Unsubscribed from command Realtime');\r\n}\r\n\r\n/**\r\n * Drain any pending commands that may have arrived while disconnected.\r\n * Called once on (re-)connect to catch anything missed.\r\n */\r\nasync function drainPendingCommands() {\r\n  if (!isSupabaseConfigured() || !currentPairingId) return;\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_commands?pairing_id=eq.${currentPairingId}&status=eq.pending&order=created_at.asc&limit=10`,\r\n      {\r\n        headers: {\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n        }\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      debug.warn('Failed to drain pending commands:', response.status);\r\n      return;\r\n    }\r\n\r\n    const commands = await response.json();\r\n    if (commands.length > 0) {\r\n      debug.log(`\uD83D\uDCE5 Draining ${commands.length} pending command(s)`);\r\n      for (const command of commands) {\r\n        await executeCommand(command);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    debug.error('Drain pending commands error:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a command from Discord\r\n */\r\nasync function executeCommand(command) {\r\n  debug.log('\u26A1 Executing command:', command.command_type, command);\r\n\r\n  try {\r\n    // Mark as processing\r\n    await updateCommandStatus(command.id, 'processing');\r\n\r\n    let result;\r\n\r\n    switch (command.command_type) {\r\n      case 'roll':\r\n        result = await executeRollCommand(command);\r\n        break;\r\n\r\n      case 'use_action':\r\n        result = await executeUseActionCommand(command, 'action');\r\n        break;\r\n\r\n      case 'use_bonus':\r\n        result = await executeUseActionCommand(command, 'bonus');\r\n        break;\r\n\r\n      case 'end_turn':\r\n        result = await executeEndTurnCommand(command);\r\n        break;\r\n\r\n      case 'use_ability':\r\n        result = await executeUseAbilityCommand(command);\r\n        break;\r\n\r\n      case 'cast':\r\n        result = await executeCastCommand(command);\r\n        break;\r\n\r\n      default:\r\n        result = { success: false, error: `Unknown command type: ${command.command_type}` };\r\n    }\r\n\r\n    // Mark as completed or failed\r\n    await updateCommandStatus(\r\n      command.id,\r\n      result.success ? 'completed' : 'failed',\r\n      result\r\n    );\r\n\r\n    debug.log('\u2705 Command executed:', command.command_type, result);\r\n  } catch (error) {\r\n    debug.error('\u274C Command execution failed:', error);\r\n    await updateCommandStatus(command.id, 'failed', null, error.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a roll command (e.g., attack roll, save, check)\r\n */\r\nasync function executeRollCommand(command) {\r\n  const { action_name, command_data } = command;\r\n\r\n  // Build roll data from command data\r\n  const rollString = command_data.roll_string || `/roll 1d20`;\r\n  const rollName = action_name || command_data.roll_name || 'Discord Roll';\r\n\r\n  // Build comprehensive roll data for Roll20\r\n  const rollData = {\r\n    formula: rollString,\r\n    name: rollName,\r\n    source: 'discord',\r\n    characterName: command_data.character_name,\r\n    characterId: command_data.character_id,\r\n    checkType: command_data.check_type,\r\n    advantage: command_data.advantage,\r\n    disadvantage: command_data.disadvantage,\r\n    count: command_data.count,\r\n    sides: command_data.sides,\r\n    modifier: command_data.modifier\r\n  };\r\n\r\n  // Send to Roll20\r\n  const result = await sendRollToAllRoll20Tabs(rollData);\r\n\r\n  if (!result || !result.success) {\r\n    const errorMsg = result?.error || 'Failed to send roll to Roll20';\r\n    debug.error('\u274C Roll command failed:', errorMsg);\r\n    return { success: false, message: errorMsg };\r\n  }\r\n\r\n  return { success: true, message: `Rolled ${rollName}` };\r\n}\r\n\r\n/**\r\n * Execute an action/bonus action use command\r\n */\r\nasync function executeUseActionCommand(command, actionType) {\r\n  const { action_name, command_data } = command;\r\n\r\n  // Send action use to Roll20 tabs\r\n  const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n  for (const tab of tabs) {\r\n    try {\r\n      await browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'useActionFromDiscord',\r\n        actionType: actionType,\r\n        actionName: action_name,\r\n        commandData: command_data\r\n      });\r\n    } catch (err) {\r\n      debug.warn(`Failed to send action to tab ${tab.id}:`, err);\r\n    }\r\n  }\r\n\r\n  return { success: true, message: `Used ${actionType}: ${action_name}` };\r\n}\r\n\r\n/**\r\n * Execute end turn command\r\n */\r\nasync function executeEndTurnCommand(command) {\r\n  const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n  for (const tab of tabs) {\r\n    try {\r\n      await browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'endTurnFromDiscord'\r\n      });\r\n    } catch (err) {\r\n      debug.warn(`Failed to send end turn to tab ${tab.id}:`, err);\r\n    }\r\n  }\r\n\r\n  return { success: true, message: 'Turn ended' };\r\n}\r\n\r\n/**\r\n * Execute use ability command (spell, feature, etc.)\r\n */\r\nasync function executeUseAbilityCommand(command) {\r\n  const { action_name, command_data } = command;\r\n\r\n  const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n  for (const tab of tabs) {\r\n    try {\r\n      await browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'useAbilityFromDiscord',\r\n        abilityName: action_name,\r\n        abilityData: command_data\r\n      });\r\n    } catch (err) {\r\n      debug.warn(`Failed to send ability use to tab ${tab.id}:`, err);\r\n    }\r\n  }\r\n\r\n  return { success: true, message: `Used ability: ${action_name}` };\r\n}\r\n\r\n/**\r\n * Execute a cast spell command from Discord\r\n */\r\nasync function executeCastCommand(command) {\r\n  const { action_name, command_data } = command;\r\n\r\n  const tabs = await browserAPI.tabs.query({ url: '*://app.roll20.net/*' });\r\n\r\n  for (const tab of tabs) {\r\n    try {\r\n      await browserAPI.tabs.sendMessage(tab.id, {\r\n        action: 'castSpellFromDiscord',\r\n        spellName: action_name,\r\n        spellData: command_data\r\n      });\r\n    } catch (err) {\r\n      debug.warn(`Failed to send cast to tab ${tab.id}:`, err);\r\n    }\r\n  }\r\n\r\n  return { success: true, message: `Cast spell: ${action_name}` };\r\n}\r\n\r\n/**\r\n * Update command status in Supabase\r\n */\r\nasync function updateCommandStatus(commandId, status, result = null, errorMessage = null) {\r\n  if (!isSupabaseConfigured()) return;\r\n\r\n  try {\r\n    const update = {\r\n      status: status,\r\n      processed_at: new Date().toISOString()\r\n    };\r\n\r\n    if (result) {\r\n      update.result = result;\r\n    }\r\n\r\n    if (errorMessage) {\r\n      update.error_message = errorMessage;\r\n    }\r\n\r\n    const response = await fetch(\r\n      `${SUPABASE_URL}/rest/v1/rollcloud_commands?id=eq.${commandId}`,\r\n      {\r\n        method: 'PATCH',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'apikey': SUPABASE_ANON_KEY,\r\n          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`\r\n        },\r\n        body: JSON.stringify(update)\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      debug.warn('Failed to update command status:', response.status);\r\n    }\r\n  } catch (error) {\r\n    debug.error('Error updating command status:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Store pairing ID for command polling\r\n */\r\nasync function storePairingId(pairingId) {\r\n  await browserAPI.storage.local.set({ discordPairingId: pairingId });\r\n  debug.log('Stored pairing ID:', pairingId);\r\n}\r\n\r\n// Auto-start command realtime subscription when extension loads and webhook is configured\r\n(async () => {\r\n  try {\r\n    const settings = await browserAPI.storage.local.get(['discordWebhookEnabled', 'discordPairingId']);\r\n    debug.log('\uD83D\uDD04 Auto-start check - webhookEnabled:', settings.discordWebhookEnabled, 'pairingId:', settings.discordPairingId ? 'set' : 'not set');\r\n    if (settings.discordWebhookEnabled && settings.discordPairingId) {\r\n      debug.log('Auto-starting command realtime subscription...');\r\n      await subscribeToCommandRealtime(settings.discordPairingId);\r\n    } else {\r\n      debug.log('\u23ED\uFE0F Skipping auto-start - webhook not enabled or no pairing ID');\r\n    }\r\n  } catch (error) {\r\n    debug.warn('Failed to auto-start command realtime:', error);\r\n  }\r\n})();\r\n\r\n// ============================================================================\r\n// Turn Posting via Supabase (for Pip Bot to add buttons)\r\n// ============================================================================\r\n\r\n/**\r\n * Post turn data to Supabase for Pip Bot to pick up and post with buttons\r\n * This enables interactive buttons on Discord messages (webhooks can't do this)\r\n */\r\nasync function postTurnToSupabase(payload) {\r\n  // Check if Supabase is configured\r\n  if (!isSupabaseConfigured()) {\r\n    // Fall back to webhook if Supabase not configured\r\n    debug.log('Supabase not configured, falling back to webhook');\r\n    return await postToDiscordWebhook(payload);\r\n  }\r\n\r\n  // Get pairing ID\r\n  const settings = await browserAPI.storage.local.get(['discordPairingId']);\r\n  if (!settings.discordPairingId) {\r\n    debug.warn('No pairing ID, falling back to webhook');\r\n    return await postToDiscordWebhook(payload);\r\n  }\r\n\r\n  const { type, characterName, round, actions, initiative } = payload;\r\n\r\n  // Map payload type to event type\r\n  const eventTypeMap = {\r\n    turnStart: 'turn_start',\r\n    turnEnd: 'turn_end',\r\n    actionUpdate: 'action_update',\r\n    combatStart: 'combat_start',\r\n    roundChange: 'round_change'\r\n  };\r\n\r\n  const eventType = eventTypeMap[type] || type;\r\n\r\n  try {\r\n    // Get character data for available actions\r\n    const characterData = await getCharacterData();\r\n    const availableActions = characterData ? extractAvailableActions(characterData) : [];\r\n\r\n    const turnData = {\r\n      pairing_id: settings.discordPairingId,\r\n      event_type: eventType,\r\n      character_name: characterName,\r\n      character_id: characterData?.id || null,\r\n      round_number: round || null,\r\n      initiative: initiative || null,\r\n      action_available: actions ? !actions.action : true,\r\n      bonus_available: actions ? !actions.bonus : true,\r\n      movement_available: actions ? !actions.movement : true,\r\n      reaction_available: actions ? !actions.reaction : true,\r\n      available_actions: availableActions,\r\n      status: 'pending'\r\n    };\r\n\r\n    const response = await fetch(`${SUPABASE_URL}/rest/v1/rollcloud_turns`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'apikey': SUPABASE_ANON_KEY,\r\n        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,\r\n        'Prefer': 'return=representation'\r\n      },\r\n      body: JSON.stringify(turnData)\r\n    });\r\n\r\n    if (response.ok) {\r\n      debug.log('\u2705 Turn posted to Supabase for Pip Bot:', eventType);\r\n      return { success: true };\r\n    } else {\r\n      const error = await response.text();\r\n      debug.warn('\u274C Failed to post turn to Supabase:', error);\r\n      // Fall back to webhook\r\n      return await postToDiscordWebhook(payload);\r\n    }\r\n  } catch (error) {\r\n    debug.error('\u274C Error posting turn to Supabase:', error);\r\n    // Fall back to webhook\r\n    return await postToDiscordWebhook(payload);\r\n  }\r\n}\r\n\r\n/**\r\n * Extract available actions from character data for Discord buttons\r\n * Returns array of { name, type, roll } objects\r\n */\r\nfunction extractAvailableActions(characterData) {\r\n  const actions = [];\r\n\r\n  // Extract attacks\r\n  if (characterData.attacks) {\r\n    for (const attack of characterData.attacks) {\r\n      actions.push({\r\n        name: attack.name,\r\n        type: 'action',\r\n        roll: attack.attackBonus ? `1d20+${attack.attackBonus}` : '1d20',\r\n        damage: attack.damage\r\n      });\r\n    }\r\n  }\r\n\r\n  // Extract spells (cantrips and prepared)\r\n  if (characterData.spells) {\r\n    for (const spell of characterData.spells) {\r\n      if (spell.prepared || spell.level === 0) {\r\n        actions.push({\r\n          name: spell.name,\r\n          type: spell.level === 0 ? 'cantrip' : 'spell',\r\n          level: spell.level,\r\n          actionType: spell.castingTime?.includes('bonus') ? 'bonus' : 'action'\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Extract common actions\r\n  actions.push(\r\n    { name: 'Dodge', type: 'action', builtin: true },\r\n    { name: 'Dash', type: 'action', builtin: true },\r\n    { name: 'Disengage', type: 'action', builtin: true },\r\n    { name: 'Help', type: 'action', builtin: true },\r\n    { name: 'Hide', type: 'action', builtin: true, roll: '1d20+stealth' }\r\n  );\r\n\r\n  return actions;\r\n}\r\n\r\n// ============================================================================\r\n// Native Messaging for Installer Communication\r\n// ============================================================================\r\n\r\nlet installerPort = null;\r\n\r\n/**\r\n * Connect to installer via native messaging\r\n */\r\nasync function connectToInstaller() {\r\n  try {\r\n    if (installerPort) {\r\n      return installerPort;\r\n    }\r\n\r\n    // Try to connect to the installer native messaging host\r\n    installerPort = browserAPI.runtime.connectNative('com.rollcloud.installer');\r\n    \r\n    installerPort.onMessage.addListener((message) => {\r\n      debug.log('Received message from installer:', message);\r\n      handleInstallerMessage(message);\r\n    });\r\n    \r\n    installerPort.onDisconnect.addListener(() => {\r\n      debug.log('Disconnected from installer');\r\n      installerPort = null;\r\n    });\r\n\r\n    // Send a ping to test connection\r\n    installerPort.postMessage({ type: 'ping' });\r\n    \r\n    debug.log('\u2705 Connected to installer via native messaging');\r\n    return installerPort;\r\n  } catch (error) {\r\n    debug.warn('Failed to connect to installer:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle messages from installer\r\n */\r\nfunction handleInstallerMessage(message) {\r\n  switch (message.type) {\r\n    case 'pong':\r\n      debug.log('\u2705 Installer is available, requesting pairing code...');\r\n      // After confirming connection, request pairing code\r\n      if (installerPort) {\r\n        installerPort.postMessage({ type: 'getPairingCode' });\r\n      }\r\n      break;\r\n\r\n    case 'pairingCode':\r\n      if (message.code) {\r\n        debug.log('\uD83D\uDCE5 Received pairing code from installer:', message.code);\r\n        // Store the pairing code and start the pairing process\r\n        handleInstallerPairingCode(message.code, message.username);\r\n      } else {\r\n        debug.log('No pairing code available from installer (code is null)');\r\n      }\r\n      break;\r\n\r\n    default:\r\n      debug.warn('Unknown message type from installer:', message.type);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle pairing code received from installer\r\n * @param {string} code - The pairing code\r\n * @param {string} installerUsername - Optional username from installer\r\n */\r\nasync function handleInstallerPairingCode(code, installerUsername = null) {\r\n  try {\r\n    // Store the pairing code\r\n    await browserAPI.storage.local.set({\r\n      installerPairingCode: code,\r\n      pairingSource: 'installer'\r\n    });\r\n\r\n    // Get DiceCloud username - prefer installer-provided, fall back to local\r\n    let diceCloudUsername = installerUsername;\r\n    if (!diceCloudUsername) {\r\n      const loginStatus = await checkLoginStatus();\r\n      diceCloudUsername = loginStatus.username || 'DiceCloud User';\r\n    }\r\n\r\n    debug.log('\uD83D\uDCE4 Creating Discord pairing with code:', code, 'username:', diceCloudUsername);\r\n\r\n    // Create pairing in Supabase\r\n    const result = await createDiscordPairing(code, diceCloudUsername);\r\n\r\n    if (result.success) {\r\n      debug.log('\u2705 Pairing created from installer code');\r\n\r\n      // Notify popup that pairing is in progress\r\n      broadcastToPopup({\r\n        action: 'installerPairingStarted',\r\n        code: code\r\n      });\r\n    } else {\r\n      debug.error('Failed to create pairing from installer code:', result.error);\r\n    }\r\n  } catch (error) {\r\n    debug.error('Error handling installer pairing code:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Broadcast message to popup if it's open\r\n */\r\nasync function broadcastToPopup(message) {\r\n  try {\r\n    // Try to send to popup via runtime message\r\n    await browserAPI.runtime.sendMessage(message);\r\n  } catch (error) {\r\n    // Popup might not be open, that's okay\r\n    debug.log('Popup not available for broadcast');\r\n  }\r\n}\r\n\r\n// Auto-connect to installer when extension loads\r\n(async () => {\r\n  setTimeout(async () => {\r\n    await connectToInstaller();\r\n  }, 2000); // Wait 2 seconds for extension to fully initialize\r\n})();\r\n"],
  "mappings": "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",
  "names": ["characterProfiles", "supabase"]
}
